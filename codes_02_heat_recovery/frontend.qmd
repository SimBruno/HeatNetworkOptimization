---
title: "Dairy Process Optimization"
author:
  - "EPFL IPESE"
unitname:
  faculty: School of Engineering
  institute: Mechanical Engineering
  laboratory: Industrial Process and Energy Systems Engineering
advisor: François Maréchal
date: "`r format(Sys.time(), '%d %B, %Y')`"
format:
    html:
        theme: simplex
        toc_depth: 3
        toc: true
        toc_float: true
        collapse: true
        smooth_scroll: true
        dev: svg
        code_folding: hide
        number_sections: true
        mathjax: default
        fig-format: svg
venv: "../venv"
---

```{r setup, warning = F, results = "hide", message=F}
source("../rosmose-setup.R", local = knitr::knit_global())
```

# Introduction {-}

This report presents ROSMOSE integration results of various scenarios studying the dairy process including it's heat integration, valorization of certain waste products, utilization of different technologies such as heat pumps and refrigerators, and optimization of the overall process to minimize cost and maximize revenue. 

# Problem Definition {-}

This project will use a model named **DairyProcess**.

This run includes:

* Dairy Process: Pasteurization, evaporation, cheese, mesost, cleaning-in-place, wastewater treatment, and disposal. 

* Utilities: Market, cooling tower, refrigerator, and heat pumps. 



## Example files

Below you will find instructions on how to call different process and utility models, how to solve your optimization problem using OSMOSE, amd how to eventually report and plot your results. 

REMEMBER these are the brewery example files, you will need to adapt them for the dairy process accordingly. Good Luck!



```{r child = 'model/BreweryProcess/BreweryProcess.Rmd'}
```

## Visualization of Brewery Process {-}


```{rosmose display et, fig.cap="breweryprocess-visualize", out.height="80%"}
: OSMOSE DISPLAY_ET breweryprocess
```




Furnace
```{r child = 'model/Furnace/Furnace.Rmd'}
```

```{rosmose display furnace, fig.cap="furnace-visualize", out.height="80%"}
: OSMOSE DISPLAY_ET furnace
```


Cooling tower
```{r child = 'model/CoolingTower/CoolingTower.Rmd'}
```

```{rosmose display coolingtower, fig.cap="coolingtower-visualize", out.height="80%"}
: OSMOSE DISPLAY_ET coolingtower
```



Refrigerator
```{r child = 'model/Refrigerator/Refrigerator.Rmd'}
```

```{rosmose display refrigerator, fig.cap="refrigerator-visualize", out.height="80%"}
: OSMOSE DISPLAY_ET refrigerator
```


Market
```{r child = 'model/Market/Market.Rmd'}
```

```{rosmose display market, fig.cap="market-visualize", out.height="80%"}
: OSMOSE DISPLAY_ET market
```






<!-- Heat pumps -->
<!-- ```{r child = 'model/Heatpump/Heatpump.Rmd'} -->
<!-- ``` -->

<!-- ```{rosmose display heatpump, fig.cap="heatpump-visualize", out.height="80%"} -->
<!-- : OSMOSE DISPLAY_ET heatpump -->
<!-- ``` -->

<!-- ```{r child = 'model/Heatpump/Heatpump2.Rmd'} -->
<!-- ``` -->

<!-- ```{rosmose display heatpump2, fig.cap="heatpump2-visualize", out.height="80%"} -->
<!-- : OSMOSE DISPLAY_ET heatpump2 -->
<!-- ``` -->

<!-- ```{r child = 'model/Heatpump/Heatpump3.Rmd'} -->
<!-- ``` -->

<!-- ```{rosmose display heatpump3, fig.cap="heatpump3-visualize", out.height="80%"} -->
<!-- : OSMOSE DISPLAY_ET heatpump3 -->
<!-- ``` -->

<!-- ```{r child = 'model/Heatpump/Heatpump4.Rmd'} -->
<!-- ``` -->

<!-- ```{rosmose display heatpump4, fig.cap="heatpump4-visualize", out.height="80%"} -->
<!-- : OSMOSE DISPLAY_ET heatpump4 -->
<!-- ``` -->





<!-- Cogeneration system -->
<!-- ```{r child = 'model/Cogeneration/cogen.Rmd'} -->
<!-- ``` -->

<!-- ```{rosmose display cogen, fig.cap="Cogeneration-visualize", out.height="80%"} -->
<!-- : OSMOSE DISPLAY_ET cogen -->
<!-- ``` -->







```{rosmose eval = F}
: TAGS DISPLAY_TAGS [nvuD]

```

```{rosmose configure solver}
: OSMOSE OPTIONS mathProg

| Property    | Value         | Comments |
|:------------|:--------------|:---------|
| language    | ampl          |          |
| solver      | gurobi        |          |
```

```{rosmose solve-osmose}
! OSMOSE SOLVE-LOCAL brewery TotalCost [breweryprocess, market, furnace, coolingtower, refrigerator]

#! OSMOSE SOLVE-LOCAL brewery MER [breweryprocess]

#! OSMOSE SOLVE-LOCAL brewery TotalCost [breweryprocess,market, coolingtower, heatpump, heatpump2, heatpump3, cogen]

#! OSMOSE SOLVE-LOCAL brewery TotalCost [breweryprocess,market, coolingtower, heatpump, heatpump2, heatpump3, heatpump4, cogen]

#! OSMOSE SOLVE-LOCAL brewery TotalCost [breweryprocess, market]





|name   |value|
|:------|:----|
|op_time|8760 |
```



Serialization

This function can be used in case you are facing errors which are not clear and you want to explore deaper into the process files in order to determine and debug your errors. 

```{rosmose}
! OSMOSE SERIALIZE_PROJECT brewery TotalCost [breweryprocess, coolingtower, market, furnace, refrigerator]
#! OSMOSE SERIALIZE_PROJECT brewery TotalCost [breweryprocess,market, coolingtower, heatpump, heatpump2, heatpump3, cogen]
#! OSMOSE SERIALIZE_PROJECT brewery MER [breweryprocess]
```

```{rosmose}
! OSMOSE SERIALIZE_ET [breweryprocess, coolingtower, market, furnace, refrigerator]
#! OSMOSE SERIALIZE_ET [breweryprocess,market, coolingtower, heatpump, heatpump2, heatpump3, cogen]
#! OSMOSE SERIALIZE_ET [et1, coolingtower, market, furnace, refrigerator]
#! OSMOSE SERIALIZE_ET [breweryprocess]
```



The following code is used to retrieve the data of the generated JSON file


This code is used to find and load certain json file:
```{r, eval=T}
library(jsonlite)
pfilename<-"result/brewery-1.json"
data <- fromJSON(pfilename, flatten=FALSE)
#x<-data$results$KPIs$opex
#y<- data$results$delta_hot[[1]]$Clu$DefaultHeatCascade
```




<!-- The following code is used to find the last existing json file and load the next json file automatically (if you want to load one specific json file, refer to the previous chunk) -->

<!-- ```{r, echo=FALSE} -->

<!-- library(jsonlite) -->

<!-- # Function to find the last existing brewery-N.json file (update with your project name instead of brewery) -->
<!-- findLastExistingJSONFile <- function() { -->
<!--   n <- 1 -->
<!--   while (file.exists(sprintf("result/brewery-%d.json", n))) { -->
<!--     n <- n + 1 -->
<!--   } -->
<!--   if (n > 1) { -->
<!--     last_existing_file <- sprintf("result/brewery-%d.json", n - 1) -->
<!--     return(last_existing_file) -->
<!--   } else { -->
<!--     return(NULL) # No existing files yet -->
<!--   } -->
<!-- } -->

<!-- # Find the last existing brewery file -->
<!-- last_JSON_file <- findLastExistingJSONFile() -->

<!-- # Load the lastest json file -->
<!-- if (!is.null(last_JSON_file)) { -->
<!--   # Get the next brewery file in the sequence -->
<!--   next_JSON_number <- as.numeric(gsub("brewery-(\\d+)\\.json", "\\1", last_JSON_file)) + 1 -->
<!--   next_JSON_file <- sprintf("result/brewery-%d.json", next_JSON_number) -->

<!--   # Load data from the next brewery file -->
<!--   if (file.exists(next_JSON_file)) { -->
<!--     data <- fromJSON(next_JSON_file, flatten = FALSE) -->
<!--     cat("Loaded data from:", next_JSON_file, "\n") -->
<!--   } -->
<!-- } else { -->
<!--   # Define the brewery file as the first -->
<!--   next_JSON_number <- 1 -->
<!--   next_JSON_file <- sprintf("result/brewery-%d.json", next_JSON_number) -->

<!--   # Load data from the first brewery file -->
<!--   if (file.exists(next_JSON_file)) { -->
<!--     data <- fromJSON(next_JSON_file, flatten = FALSE) -->

<!--     cat("Loaded data from:", next_JSON_file, "\n") -->
<!--   }  -->

<!-- } -->


<!-- # Construct the path to frontend_brewery.html -->
<!-- html_file_path <- file.path("frontend_brewery.html") -->

<!-- # Open the HTML file in the default web browser -->
<!-- browseURL(html_file_path) -->


<!-- ``` -->


The following code is about reporting the optimization results and plotting the pertinent plots for the corresponding optimization scenarios


# Optimization Results {-}

<!-- ## Capital and Operational Expenditures {-} -->

<!-- ```{r print economic results} -->
<!-- cat("CAPEX:", data$results$KPIs$capex) -->
<!-- cat("OPEX:", data$results$KPIs$opex) -->
<!-- ``` -->

<!-- ## Energy Requirements {-} -->

<!-- ```{r print energy results} -->
<!-- cat("Minimum Heating Requirement:", data$results$delta_hot[[1]]$Clu$DefaultHeatCascade, "kW","\n") -->
<!-- cat("Minimum Cooling Requirement:", data$results$delta_cold[[1]]$Clu$DefaultHeatCascade, "kW") -->
<!-- ``` -->

## Plots {-}

**Hot and cold Composite curves**

```{r cc, eval = TRUE}
display_cc <- function(time=1){
  graphs <- data$results$graph[[1]]
  graph <- graphs[[time]]
  graph <- graph[graph$plot_type == "cc",]$data[[1]]
  hcc <- graph[graph$title == "Hot streams",]$curve[[1]]
  ccc <- graph[graph$title == "Cold streams",]$curve[[1]]

  if (!is_empty(hcc) && !is_empty(ccc)){
    plot_ly() %>%
            add_trace(x=hcc$Q, y=hcc$T-273.15, mode = 'lines', line=list(color='red'), name='Hot Streams') %>%
            add_trace(x=ccc$Q, y=ccc$T-273.15, mode = 'lines', line=list(color='blue'),  name='Cold Streams') %>%
            layout(xaxis= list(title = "Heat load [kW]"),
                   yaxis= list(title = "Corrected Temperature [°C]"),
                   margin= list(l=50, r=0, b=40, t=40),
                   title = "Composite Curves"
            )


  } else {
    print(paste("There is no CC for timestep", time))
  }
}

display_cc()
```

**Grand Composite Curve**

```{r gcc, eval = TRUE}
display_gcc <- function(time=1){
  graphs <- data$results$graph[[1]]
  graph <- graphs[[time]]
  graph <- graph[graph$plot_type == "gcc",]$data[[1]]
  gcc <- graph$curve[[1]]

  if (!is_empty(gcc)){
    plot_ly() %>%

      add_trace(x=gcc$Q, y=gcc$T-273.15, mode = 'lines', line=list(color='green'), name='GCC') %>%
      layout(xaxis= list(title = "Heat load [kW]"),
             yaxis= list(title = "Corrected Temperature [°C]"),
             margin= list(l=50, r=50, b=40, t=40),
             title = "Grand Composite Curve"
            )
  } else {
    print(paste("There is no GCC for timestep", time))
  }
}

display_gcc()
```






**Integrated Composite Curve**

```{r icc, eval = TRUE}
display_icc <- function(time=1){
  graphs <- data$results$graph[[1]]
  graph <- graphs[[time]]
  graph <- graph[graph$plot_type == "icc.utilities",]$data[[1]]
  base <- graph[graph$title == "base",]$curve[[1]]
  utilities <- graph[graph$title == "utilities",]$curve[[1]]

  if (!is_empty(base) && !is_empty(utilities)){
    plot_ly() %>%
            add_trace(x=base$Q, y=base$T-273.15, mode = 'lines', line=list(color='red'),  name='base') %>%
            add_trace(x=utilities$Q, y=utilities$T-273.15, mode = 'lines', line=list(color='blue'),  name='utilities') %>%
            layout(xaxis= list(title = "Heat load [kW]"),
                   yaxis= list(title = "Corrected Temperature [°C]"),
                   margin= list(l=50, r=20, b=40, t=40),
                   yaxis2 = list(overlaying = "y", side = "right", title = 'Carnot factor 1-To/T [-]'),
                   title = "Integrated Composite Curve"
            )

  } else {
    print(paste("There is no ICC for timestep", time))
  }
}

display_icc()
```



**Thermal Exergy of Integrated Utilities**

```{r carnot, eval = TRUE}
display_carnot <- function(time=1){
  graphs <- data$results$graph[[1]]
  graph <- graphs[[time]]
  graph <- graph[graph$plot_type == "carnot.utilities",]$data[[1]]
  base <- graph[graph$title == "base",]$curve[[1]]
  utilities <- graph[graph$title == "utilities",]$curve[[1]]

  if (!is_empty(base) && !is_empty(utilities)){
    plot_ly() %>%
            add_trace(x=base$Q, y=base$T, mode = 'lines', line=list(color='red'), name='base') %>%
            add_trace(x=utilities$Q, y=utilities$T, mode = 'lines', line=list(color='blue'),  name='utilities') %>%
            layout(xaxis= list(title = "Heat load [kW]"),
                   yaxis= list(title = "Carnot factor 1-To/T [-]"),
                   margin= list(l=50, r=20, b=40, t=40),
                   title = "Thermal Exergy of Integrated Utilities"
            )

  } else {
    print(paste("There is no Carnot for timestep", time))
  }
}

display_carnot(1)
```





## Heat Exchanger Network {-}

The heat exchanger network area required to attain the minimum energy requirement is extracted from OSMOSE optimization results.
The minimum number of heat exchangers for the network and average area per heat exchanger can also be calculated from the simulation outputs.
Next the cost of this heat exchanger network can be computed based on the equations published in Turton 1998 and corrected by the chemical engineering plant cost index (CEPCI) for 2023.

```{r, eval = TRUE}
get_HEN <- function () {
  spag_area <- data$results$spaghetti[[1]]$Clu$DefaultHeatCascade$area_total
  min_number_HEX <- data$results$spaghetti[[1]]$Clu$DefaultHeatCascade$HEs
  hex_area <- spag_area / min_number_HEX
  n <- 15 # years, lifetime of a heat exchanger
  i <- 0.05 # fractional interest rate per year
  an_factor <- (i*(1+i)^n/((1+i)^n-1))
  k1 <- 3.2138
  k2 <- 0.2685
  k3 <- 0.07961
  Fp <- (10^(k1+ k2*log10(hex_area)+ k3*(log10(hex_area))^2))
  Fm <- 3 #stainless steel shell and tube
  B1 <- 1.8
  B2 <- 1.5
  F_BM <- (B1+(B2*Fm*Fp))
  CEPCI_1998 <- 382
  CEPCI_2023 <- 600
  c_hen <- (F_BM*(CEPCI_2023/CEPCI_1998)*an_factor*min_number_HEX)
  return(list("hen_area" = spag_area,"min_number_HEX" = min_number_HEX ,"hex_area" = hex_area, "an_factor" = an_factor, "c_hen"= c_hen))
}

hen <- get_HEN()
```


Heat exchanger network area: `r hen$hen_area` m^2^.

Minimum number of heat exchangers: `r hen$min_number_HEX`.

Average area per heat exchanger: `r hen$hex_area` m^2^.

Annualized cost of heat exchanger network: `r hen$c_hen` $/y.

Annualization factor: `r hen$an_factor`.

