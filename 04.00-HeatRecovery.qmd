

# Pinch analysis
Starting from this chapter, you will embark on optimizing the energy efficiency of the dairy factory. This section is divided into two parts:

- Optimization of the minimum temperature difference ($\Delta$T) in heat exchangers.
- Determining the minimum energy requirement of the factory through the application of pinch analysis.

## Optimization of $\Delta$T minimum

> **Task Instructions**
>
>This section corresponds to Task 4 of your [project](https://ipese-lectures.epfl.ch/advanced-energetics/project-description/project-5.html#industrial-round-table-4). In this segment, you are required to include the following elements:
>
>- Theoretical Background: Provide a thorough theoretical foundation for your optimization problem. Explain concepts such as how to calculate heat exchanger area and how to estimate heat exchanger investment. Offer insights into the underlying principles and equations involved.
>- Assumptions: Clearly outline the assumptions you have made regarding the parameters and variables within your optimization formulas. This includes assumptions related to heat exchanger characteristics, costs, and other relevant factors.
>- Optimization Results: Present your optimization outcomes using graphical representations or tables. If possible, consider leveraging R and Python libraries to create figures and visualizations, as this may enhance your presentation. **You will receive bonus points if you meet to do so.**

### Past 5 only

```{python past5only, echo = T, eval = T}
#The goal of this part is to determine an optimized dTmin such that costs are minimized. 
#In all scenarios we will do the following:
#1. Determine the area of the HX in term of the dTmin
#2. Determine the cost of the HX in term of the the Area
#3. Determine the cost of the HX in term of the dTmin

# ##Scenario 1: dTmin for the past5 

# ### Determine the area of the HX in term of the dTmin
import matplotlib
matplotlib.use('Agg')
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from IPython.display import display, HTML
#from codes_01_energy_bill.coolprop_functions import mixture

#####
def Dtmin(dT, T1, T1v, T2, T2_prime, m2, cp2, position, pastnb):
    
    if position == 'left':
        T1_prime = T2 - dT
    elif position == 'right':
        T1_prime = T1v.max()
    
    #Find the minimum Area of the HX
    Q = m2*cp2*(T2-T2_prime)
    alpha= 1000 #W/m^2°C, assumption based on alpha_H20 since 65wt% of the stream is water 
    U = alpha/2
    dtA = abs(T2-T1_prime)  # to be sure we have a positive value in the ln() of the LMTD
    dtB = abs(T1-T2_prime)
    LMTD = (dtA-dtB)/np.log(dtA/dtB)
    Area = Q/(U*LMTD)
    #Find the CAPEX

    CEPCI2019=603.1 
    CEPCI1998=389.5 #https://personalpages.manchester.ac.uk/staff/tom.rodgers/Interactive_graphs/CEPCI.html?reactors/CEPCI/index.html
    K1=3.6788 #sl 12 T4.1 assumption flat plate HX
    K2=0.4412
    FBM=4.74 #assumption fluid sl 10 T4.1
    i=0.05 #sl 8 T4.2
    e=0.92 #€/$ exchange rate 2023 Nov 
    n=20

    Cp = CEPCI2019/CEPCI1998 * 10**(K1+K2*np.log(Area))

    CBM = Cp*FBM*e

    ANNUALIZATIONFACTOR = (i*(1+i)**n)/((1+i)**n-1)

    CAPEX = ANNUALIZATIONFACTOR*CBM

    #Find the OPEX
    top = 24*0.95*365 #h/year
    gas_fr = 0.08 # €/kWh
    gas_ger = 0.08 # €/kWh 
    elec_fr = 0.12 # €/kWh
    elec_ger = 0.21 # €/kWh
    COP = 3.5 #same assumption in Energy Bill

    if pastnb == 5:
        Qpast6 = m2*cp2*(T2-T1_prime)
        OP6_fr = gas_fr * Qpast6/1000 * top
        OP6_ger = gas_ger * Qpast6/1000 * top

        Qpast7 = m2*cp2*(T2_prime-277)  #T7 = 4°C = 277K
        Wpast7 = Qpast7/COP

        OP7_fr = elec_fr * Wpast7/1000 * top  
        OP7_ger = elec_ger * Wpast7/1000 * top 

        OPEX_fr = OP6_fr + OP7_fr
        OPEX_ger = OP6_ger + OP7_ger

    elif pastnb == 1:
        Qpast2 = m2*cp2*(348-T2)
        OP2_fr = gas_fr * Qpast2/1000 * top
        OP2_ger = gas_ger * Qpast2/1000 * top

        #Qpast 3 is neglect since the difference temepreature is not that high anymore

        Qpast4 = m2*cp2*(T2_prime-277)  #T7 = 4°C = 277K
        Wpast4 = Qpast4/COP

        OP4_fr = elec_fr * Wpast4/1000 * top  
        OP4_ger = elec_ger * Wpast4/1000 * top 

        OPEX_fr = OP2_fr + OP4_fr
        OPEX_ger = OP2_ger + OP4_ger

    #Find the TOTEX
    TOTEX_fr = CAPEX + OPEX_fr
    TOTEX_ger = CAPEX + OPEX_ger

    return CAPEX, OPEX_fr, OPEX_ger, TOTEX_fr, TOTEX_ger, Area

# Scenario 1: dTmin for the past5

#In our code 1 stands for cold stream and 2 for hot stream. 
#When we have a T#number it is related to the entrance of te stream and _prime relate to the exiting
#The _Number stands for the past number
#T2_prime_2 stands for the T_hout of the past2 HX

T1_5 = 333
T2_5 = 348

p1_5 = 100000

m1_5 = 0.48
m2_5 = 0.55

h1_5 = -91021.1032324004*m1_5  #from mixture with dry = 35% and wet = 65%
h2_5 = -38880.66837888083*m2_5

cp1_5 = 3470.44348
cp2_5 = 3482.1944

slope1_5 = 1/(m1_5*cp1_5)
slope2_5 = 1/(m2_5*cp2_5)

#Plot the two lines with T on the y-axis and h on the x-axis
#h is the enthalpy of the stream between h1 and h2
N = 100
h_5 = np.linspace(h1_5, h2_5, N)

C1_5 = T1_5 - slope1_5*h1_5
T1v_5 = slope1_5*h_5 + C1_5

C2_5 = T2_5 - slope2_5*h2_5
T2v_5 = slope2_5*h_5 + C2_5

T2_prime_5 = T2v_5.min()

# Create trace for Cold Stream
trace_cold = go.Scatter(x=h_5, y=T1v_5, mode='lines', name='Cold Stream')
# Create trace for Hot Stream
trace_hot = go.Scatter(x=h_5, y=T2v_5, mode='lines', name='Hot Stream')
# Create layout
layout = go.Layout(
    title='Temperature vs Enthalpy',
    xaxis=dict(title='Enthalpy (J)'),
    yaxis=dict(title='Temperature (K)'),
    legend=dict(x=0, y=1, traceorder='normal'),
    showlegend=True
)
# Create figure
fig = go.Figure(data=[trace_cold, trace_hot], layout=layout)
# Plot the vertical line at dTmin
dt_5 = T2v_5 - T1v_5
dTmin_5 = dt_5.min()
min_index_5 = dt_5.argmin()
fig.add_shape(
    type='line',
    x0=h_5[min_index_5],
    x1=h_5[min_index_5],
    y0=min(T1v_5[min_index_5], T2v_5[min_index_5]),
    y1=max(T1v_5[min_index_5], T2v_5[min_index_5]),
    line=dict(color='red', dash='dash')
)

print('dTmin =', round(dTmin_5, 3), 'K at h =', round(h_5[min_index_5], 3), 'kJ/kg')

#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results

CAPEXv_5 = []
OPEX_frv_5 = []
OPEX_gerv_5 = []
TOTEX_frv_5 = []
TOTEX_gerv_5 = []
Areav_5 = []

dt_5 = np.linspace(0.1, 30, 300)

for t in dt_5:
    CAPEX_5, OPEX_fr_5, OPEX_ger_5, TOTEX_fr_5, TOTEX_ger_5, Area_5 = Dtmin(t, T1_5, T1v_5, T2_5, T2_prime_5, m2_5, cp2_5, 'left', 5)
    CAPEXv_5.append(CAPEX_5)
    OPEX_frv_5.append(OPEX_fr_5)
    OPEX_gerv_5.append(OPEX_ger_5)
    TOTEX_frv_5.append(TOTEX_fr_5)
    TOTEX_gerv_5.append(TOTEX_ger_5)
    Areav_5.append(Area_5)

#plot the results with respect to the dt values

# Create traces for each cost component
trace_capex = go.Scatter(x=dt_5, y=CAPEXv_5, mode='lines', name='CAPEX', line=dict(color='black'))
trace_opex_france = go.Scatter(x=dt_5, y=OPEX_frv_5, mode='lines', name='OPEX (France)', line=dict(color='blue'))
trace_opex_germany = go.Scatter(x=dt_5, y=OPEX_gerv_5, mode='lines', name='OPEX (Germany)', line=dict(color='red'))
trace_totex_france = go.Scatter(x=dt_5, y=TOTEX_frv_5, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))
trace_totex_germany = go.Scatter(x=dt_5, y=TOTEX_gerv_5, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))

# Create layout
layout = go.Layout(
    title='Costs vs dTmin',
    xaxis=dict(title='dTmin (K)'),
    yaxis=dict(title='Costs (€)'),
    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),
    showlegend=True
)

# Create figure
fig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)

# Mark the minima points
min_index_fr_5 = np.argmin(TOTEX_frv_5)
fig = fig.add_trace(go.Scatter(x=[dt_5[min_index_fr_5]], y=[TOTEX_frv_5[min_index_fr_5]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))

min_index_ger_5 = np.argmin(TOTEX_gerv_5)
fig = fig.add_trace(go.Scatter(x=[dt_5[min_index_ger_5]], y=[TOTEX_gerv_5[min_index_ger_5]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))

# Show the figure
fig.show()

#print the area, dt, CAPEX, OPEX, TOTEX for the minimum TOTEX

dtmin_opt_5 = dt_5[min_index_fr_5]
area_opt_5 = Areav_5[min_index_fr_5]
CAPEX_opt_5 = CAPEXv_5[min_index_fr_5]
OPEX_fr_opt_5 = OPEX_frv_5[min_index_fr_5]
OPEX_ger_opt_5 = OPEX_gerv_5[min_index_fr_5]
TOTEX_fr_opt_5 = TOTEX_frv_5[min_index_fr_5]
TOTEX_ger_opt_5 = TOTEX_gerv_5[min_index_fr_5]
Past5_opt = pd.DataFrame({'dTmin [K]': dtmin_opt_5, 'Area [m^2]': area_opt_5, 'CAPEX[€/yr]': CAPEX_opt_5, 'OPEX_fr[€/yr]': OPEX_fr_opt_5, 'OPEX_ger[€/yr]': OPEX_ger_opt_5, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_5, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_5}, index=[0])
Past5_opt = Past5_opt.round(2)
HTML(Past5_opt.to_html(index=False))
```

### Past 1 + Past 5

```{python past1+5, echo = T, eval = T}
# Scenario 2: dTmin for the past1+past6

#This time we know only T_cin and T_cout but nothing about the hot streams
#We can't reuse the exact same method as for past6 where we knew T_hin and T_cin
#We will first determine T_cin from the Past2 HX on which we can reuse the same method as for past6

# PAST2 Intermediate HX to determine T_cin

T1_2 = 333
T2_2 = 348

p1_2 = 100000

m1_2 = 7.52
m2_2 = 7.52

h1_2 = 136414.15*m1_2  #from mixture with dry = 11.7% and wet = 88.3%
h2_2 = 195671.23*m2_2

cp1_2 = 3946.06
cp2_2 = 3955.46

#mcp_cold < mcp_hot verified

slope1_2 = 1/(m1_2*cp1_2)
slope2_2 = 1/(m2_2*cp2_2)

#Plot the two lines with T on the y-axis and h on the x-axis
#h is the enthalpy of the stream between h1 and h2
N = 100
h_2 = np.linspace(h1_5, h2_5, N)

C1_2 = T1_2 - slope1_2*h1_2
T1v_2 = slope1_2*h_2 + C1_2

C2_2 = T2_2 - slope2_2*h2_2
T2v_2 = slope2_2*h_2 + C2_2

T2_prime_2 = T2v_2.min()  #This value is T_hout and will be our T_hin for the past1
#print('T2_prime_2 = ', T2_prime_2)
#Check the T_cout to be sure it is coherent 
dt_2 = T2v_2-T1v_2
dTmin_2 = dt_2.min()
T1_prime_2 = T2_2 - dTmin_2 
#print(T1_prime_2) #WEIRD Results (T1_prime_2 almost = 75°C which would make the PAST3 irrelevant)

# PAST1 

T1_1 = 277
T2_1 = T2_prime_2

p1_1 = 100000

m1_1 = 8
m2_1 = 7.52

h1_1 = -84420.13*m1_1   #from mixture function with dry = 11.7% and wet = 88.3%
h2_1 = -18059.7680*m2_1

cp1_1 = 3963.18
cp2_1 = 3941.70

#This time mcp_cold > mcp_hot --> HOW TO DO ??? Assume I didn't see it and do the same as for past6

slope1_1 = 1/(m1_1*cp1_1)
slope2_1 = 1/(m2_1*cp2_1)

#Plot the two lines with T on the y-axis and h on the x-axis
#h is the enthalpy of the stream between h1 and h2
N = 100
h_1 = np.linspace(h1_1, h2_1, N)

C1_1 = T1_1 - slope1_1*h1_1
T1v_1 = slope1_1*h_1 + C1_1

C2_1 = T2_1 - slope2_1*h2_1
T2v_1 = slope2_1*h_1 + C2_1

T2_prime_1 = T2v_1.min()

# Create trace for Cold Stream
trace_cold = go.Scatter(x=h_1, y=T1v_1, mode='lines', name='Cold Stream')

# Create trace for Hot Stream
trace_hot = go.Scatter(x=h_1, y=T2v_1, mode='lines', name='Hot Stream')

# Create layout
layout = go.Layout(
    title='Temperature vs Enthalpy',
    xaxis=dict(title='Enthalpy (J)'),
    yaxis=dict(title='Temperature (K)'),
    legend=dict(x=0, y=1, traceorder='normal'),
    showlegend=True
)

# Create figure
fig = go.Figure(data=[trace_cold, trace_hot], layout=layout)

# Plot the vertical line at dTmin
dt_1 = T2v_1 - T1v_1
dTmin_1 = dt_1.min()
min_index_1 = dt_1.argmin()
fig = fig.add_shape(
    type='line',
    x0=h_1[min_index_1],
    x1=h_1[min_index_1],
    y0=min(T1v_1[min_index_1], T2v_1[min_index_1]),
    y1=max(T1v_1[min_index_1], T2v_1[min_index_1]),
    line=dict(color='red', dash='dash')
)

# Show the figure
fig.show()

print('dTmin = ', round(dTmin_1,3), 'K at h = ', round(h_1[min_index_1],3), 'kJ/kg')

#This time the the dTmin is on the left of the curves and thus dTmin = T_hout-T_cin (instead of T_hin-Tcout as in past6)

#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results

CAPEXv_1 = []
OPEX_frv_1 = []
OPEX_gerv_1 = []
TOTEX_frv_1 = []
TOTEX_gerv_1 = []
Areav_1 = []

dt_1 = np.linspace(0, 30, 300)

for t in dt_1:
    CAPEX_1, OPEX_fr_1, OPEX_ger_1, TOTEX_fr_1, TOTEX_ger_1, Area_1 = Dtmin(t, T1_1, T1v_1, T2_1, T2_prime_1, m2_1, cp2_1, 'right', 1)
    CAPEXv_1.append(CAPEX_1)
    OPEX_frv_1.append(OPEX_fr_1)
    OPEX_gerv_1.append(OPEX_ger_1)
    TOTEX_frv_1.append(TOTEX_fr_1)
    TOTEX_gerv_1.append(TOTEX_ger_1)
    Areav_1.append(Area_1)

min_index_fr_1 = np.argmin(TOTEX_frv_1)
#plt.plot(dt_1[min_index_fr_1], TOTEX_frv_1[min_index_fr_1], 'bo')
min_index_ger_1 = np.argmin(TOTEX_gerv_1)
#plt.plot(dt_1[min_index_ger_1], TOTEX_gerv_1[min_index_ger_1], 'ro')
#plt.show()

dtmin_opt_1 = dt_1[min_index_fr_1]
area_opt_1 = Areav_1[min_index_fr_1]
CAPEX_opt_1 = CAPEXv_1[min_index_fr_1]
OPEX_fr_opt_1 = OPEX_frv_1[min_index_fr_1]
OPEX_ger_opt_1 = OPEX_gerv_1[min_index_fr_1]
TOTEX_fr_opt_1 = TOTEX_frv_1[min_index_fr_1]
TOTEX_ger_opt_1 = TOTEX_gerv_1[min_index_fr_1]
Past6_opt = pd.DataFrame({'dTmin [K]': dtmin_opt_1, 'Area [m^2]': area_opt_1, 'CAPEX[€/yr]': CAPEX_opt_1, 'OPEX_fr[€/yr]': OPEX_fr_opt_1, 'OPEX_ger[€/yr]': OPEX_ger_opt_1, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_1, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_1}, index=[0])

#plot the results with respect to the dt values

dt_15 = np.linspace(0, 30, 300)
CAPEXv_15 = []
OPEX_frv_15 = []
OPEX_gerv_15 = []
TOTEX_frv_15 = []
TOTEX_gerv_15 = []

for i in range(0, len(dt_15)):
    CAPEXv_15.append(CAPEXv_1[i] + CAPEXv_5[i])
    OPEX_frv_15.append(OPEX_frv_1[i] + OPEX_frv_5[i])
    OPEX_gerv_15.append(OPEX_gerv_1[i] + OPEX_gerv_5[i])
    TOTEX_frv_15.append(TOTEX_frv_1[i] + TOTEX_frv_5[i])
    TOTEX_gerv_15.append(TOTEX_gerv_1[i] + TOTEX_gerv_5[i])

# Create traces for each cost component
trace_capex = go.Scatter(x=dt_15, y=CAPEXv_15, mode='lines', name='CAPEX', line=dict(color='black'))
trace_opex_france = go.Scatter(x=dt_15, y=OPEX_frv_15, mode='lines', name='OPEX (France)', line=dict(color='blue'))
trace_opex_germany = go.Scatter(x=dt_15, y=OPEX_gerv_15, mode='lines', name='OPEX (Germany)', line=dict(color='red'))
trace_totex_france = go.Scatter(x=dt_15, y=TOTEX_frv_15, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))
trace_totex_germany = go.Scatter(x=dt_15, y=TOTEX_gerv_15, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))

# Create layout
layout = go.Layout(
    title='Costs vs dTmin',
    xaxis=dict(title='dTmin (K)'),
    yaxis=dict(title='Costs (€)'),
    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),
    showlegend=True
)

# Create figure
fig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)

# Mark the minima points
min_index_fr_15 = np.argmin(TOTEX_frv_15)
fig = fig.add_trace(go.Scatter(x=[dt_15[min_index_fr_15]], y=[TOTEX_frv_15[min_index_fr_15]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))

min_index_ger_15 = np.argmin(TOTEX_gerv_15)
fig = fig.add_trace(go.Scatter(x=[dt_15[min_index_ger_15]], y=[TOTEX_gerv_15[min_index_ger_15]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))

# Show the figure
fig.show()

## Combining PAST1 and PAST5
dtmin_opt_15 = dtmin_opt_1 + dtmin_opt_5
area_opt_15 = area_opt_1 + area_opt_5
CAPEX_opt_15 = CAPEX_opt_1 + CAPEX_opt_5
OPEX_fr_opt_15 = OPEX_fr_opt_1 + OPEX_fr_opt_5
OPEX_ger_opt_15 = OPEX_ger_opt_1 + OPEX_ger_opt_5
TOTEX_fr_opt_15 = TOTEX_fr_opt_1 + TOTEX_fr_opt_5
TOTEX_ger_opt_15 = TOTEX_ger_opt_1 + TOTEX_ger_opt_5
Past15_opt = pd.DataFrame({'dTmin [K]': dtmin_opt_15, 'Area [m^2]': area_opt_15, 'CAPEX[€/yr]': CAPEX_opt_15, 'OPEX_fr[€/yr]': OPEX_fr_opt_15, 'OPEX_ger[€/yr]': OPEX_ger_opt_15, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_15, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_15}, index=[0])
Past15_opt = Past15_opt.round(2)
HTML(Past15_opt.to_html(index=False))
```

### Past 5 + recovery HEX

Past 5 + recovery HEX

### Cleaning in Place

Cleaning in Place

## Minimum energy requirement

The minimum energy requirement, including both heat and cooling demand, can be determined through the application of pinch analysis. In the Survival Guide, you can find an example of using QRosmose to conduct pinch analysis for a brewery plant. For your project, you are expected to employ the same methodology to analyze the dairy factory. While more detailed tutorials will be provided during the semester, the TA team will also be available to assist you as needed.

In your report, we would like to see the following:

- Brief Introduction to Pinch Analysis: Provide a **short** introduction to pinch analysis and explain how it is used to calculate the minimum energy requirement.
- Analysis Results: Present the outcomes of your analysis, including any assumptions you have made. An essential question to address is: How do you determine the minimum temperature difference for the entire system? This question has not been adequately answered by previous students in this course.

Furthermore, feel free to utilize R and Python code chunks to generate visually appealing graphs and tables. You can refer to the examples provided below or in the Survival Guide.

```{r}
library(jsonlite)
pfilename<-"codes_02_heat_recovery/result/brewery-1.json"
data <- fromJSON(pfilename, flatten=FALSE)
totex<-data$results$KPIs$totalcost
capex<-data$results$KPIs$capex
opex<-data$results$KPIs$opex

costs<-data.frame(totex, opex, capex)
```

```{r costs-tab, tidy=T}
knitr::kable(
  costs, caption = 'Here is a nice table',
  booktabs = TRUE
)
```

```{python, echo = T, eval = T, fig.cap='Here is a nice graph'}
import matplotlib.pyplot as plt
import json
import numpy as np

plt.switch_backend('agg')

# read json for heat integration data
file_name = open('codes_02_heat_recovery/result/brewery-1.json')
integ = json.loads(file_name.read())

# we used .keys() and json-reader to locate the data of interest (hot and cold composite curves)
hotcc = integ["results"]["graph"][0][0][1]["data"][0]["curve"]
coldcc = integ["results"]["graph"][0][0][1]["data"][1]["curve"]

# extract the temperature (T in Kelvin) and heat (Q in kW)
T_hc = [i["T"] for i in hotcc]
Q_hc = [i["Q"] for i in hotcc]
T_cc = [i["T"] for i in coldcc]
Q_cc = [i["Q"] for i in coldcc]

# compute the shifted carnot factor (1 - T0/T) and Treference = 298.15K
Tref = 298.15 
ca_hc = [(1-Tref/i) for i in T_hc]
ca_cc = [(1-Tref/i) for i in T_cc]

# compute back the original carnot factors given a deltaT_min
deltaT_min = 40
T_hc_ori = [(i+deltaT_min/2) for i in T_hc]
T_cc_ori = [(i-deltaT_min/2) for i in T_cc]
ca_hc_ori = [(1-298.15/i) for i in T_hc_ori]
ca_cc_ori = [(1-298.15/i) for i in T_cc_ori]

# prepare the second y-axis for plotting
# the minim carnot value is extracted from the original cooling. Round it to the lowest .0
# the maximum carnot carnot value is extracted from the original heating. Round it to the highest .0
ca_min = round(min(ca_cc_ori) - 0.05, 1)
ca_max = round(max(ca_hc_ori) + 0.05, 1)
# generate an array with the carnot list from min to max
ca_values = np.arange(ca_min, ca_max, 0.2)
# compute the corresponding temperature values in celcius
Tref_ce = 298.15
T_ce = [int(Tref_ce/(1-i) - 273.15) for i in ca_values]

# plot the composite curves
figure, ax = plt.subplots(figsize = (8,6))

# both cold curves (blue): dashed --> shifted, solid --> original
ax.plot(Q_cc, ca_cc, "--b")
ax.plot(Q_cc, ca_cc_ori, "-b")
# both hot curves (red): dashed --> shifted, solid --> original
ax.plot(Q_hc, ca_hc, "--r")
ax.plot(Q_hc, ca_hc_ori, "-r")
# fill the area between the original and shifted curves
ax.fill_between(Q_cc, ca_cc_ori, ca_cc, color="blue", alpha=0.25)
ax.fill_between(Q_hc, ca_hc, ca_hc_ori, color="red", alpha=0.25)

# add the lables and title
ax.set_xlabel('$Heat \ Load \ (kW)$', labelpad=12)
ax.set_ylabel('$Carnot \ Factor \ (1 - T_{0}/T)$')
ax.set_title('$System \ Heat \ Integration$')
ax.legend(["Corrected Cold Composite Curve", "Cold Composite Curve", "Corrected Hot Composite Curve", "Hot Composite Curve"])
ax.set_ybound(ca_min, ca_max)

# secondary axis. In this case we don't plot anything, we simply set the secondary axis ticks
ax2 =ax.twinx()
ax2.set_yticks(np.arange(0, len(T_ce), 1), T_ce)
ax2.set_ylabel('$Temperature \ (\u00b0C)$', labelpad=10)

plt.show()

# save the plot as a png
figure.savefig("composite_curves.png", format="png", dpi=600)
```











