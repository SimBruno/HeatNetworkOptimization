

# Pinch analysis
Starting from this chapter, you will embark on optimizing the energy efficiency of the dairy factory. This section is divided into two parts:

- Optimization of the minimum temperature difference ($\Delta$T) in heat exchangers.
- Determining the minimum energy requirement of the factory through the application of pinch analysis.

## Optimization of $\Delta$T minimum

<!---
> **Task Instructions**
>
>This section corresponds to Task 4 of your [project](https://ipese-lectures.epfl.ch/advanced-energetics/project-description/project-5.html#industrial-round-table-4). In this segment, you are required to include the following elements:
>
>- Theoretical Background: Provide a thorough theoretical foundation for your optimization problem. Explain concepts such as how to calculate heat exchanger area and how to estimate heat exchanger investment. Offer insights into the underlying principles and equations involved.
>- Assumptions: Clearly outline the assumptions you have made regarding the parameters and variables within your optimization formulas. This includes assumptions related to heat exchanger characteristics, costs, and other relevant factors.
>- Optimization Results: Present your optimization outcomes using graphical representations or tables. If possible, consider leveraging R and Python libraries to create figures and visualizations, as this may enhance your presentation. **You will receive bonus points if you meet to do so.**
--->

The goal of this part is to determine an optimized dTmin such that costs are minimized. 
In all scenarios we will do the following:

- Determine the area of the HX in term of the dTmin
- Determine the cost of the HX in term of the the Area
- Determine the cost of the HX in term of the dTmin

The costs will be computed for both France and Germany and will be composed of CAPEX and OPEX.

The idea is too be able to determine if this optimized dTmin enables costs reduction compared to the assumed ∆Tmin of 5K in the Mass/Energy Balances and Energy Bill.

Four different scenarios will be considered:

- Past 5 only
- Past 1 + Past 5 combined
- An addditional heat recovery for pasteurization
- Heat Recovery in Cleaning In Place (CIP) process

The three first scenari focus on the pasterization process whereas the later is about the CIP process.

### General Method

#### Initialisation
First, the T-h diagram of the cold and hot streams is plotted to determined if the dTmin is on the left or right of the diagram (i.e. if the dTmin is between the inlet and outlet temperatures of the cold stream or the hot stream). This will influence in the following formulas of CAPEX.

In the case of $h_1 < h_2$. The equation of T-h diagram is:

$$
T_{cold}(h) = \frac{h}{m_1 c_{p,1}} + T_{1} - \frac{h_1}{m_1 c_{p,1}}
$${#eq-slope_cold}

$$
T_{hot}(h) = \frac{h}{m_2 c_{p,2}} + T_{2} - \frac{h_2}{m_2 c_{p,2}}
$${#eq-slope_hot}

Then, the dTmin is graphically determined on the right or on the left as the minimum difference between the two curves.

If dTmin is on the right:
$$
T_{cold,out} = T_{hot,in} - dT
$${#eq-right1}
$$
T_{cold,in} = T_{cold}(h_1)
$${#eq-right2}

If dTmin is on the left:
$$
T_{cold,out} = T_{cold}(h_2)
$${#eq-left1}
$$
T_{cold,in} = T_{cold,in} + dT
$${#eq-left2}

#### Investement cost (CAPEX)

The heat exchanger area needs to be computed to get the CAPEX. 

$$
A_{ex} = \frac{Q_{ex}}{U \cdot LMTD}
$${#eq-Aex}

where:

- Qex is the heat exchanged between the two streams

$$
Q = m_{cold} \cdot c_{p,c} \cdot (T_{c,in}-T_{c,out})
  = m_{hot} \cdot c_{p,h} \cdot (T_{h,out}-T_{h,in})
$${#eq-Q}

- U, the total heat transfer coefficient, is assumed to be the half of the heat transfer coefficient of water ($1000 W/m^2K$) since the heat exchanger thickness is way smaller than 1 meter.
$$
U = \frac{\alpha}{2}
$${#eq-U}

- LMTD, the logarithmic mean temperature difference, is computed as follow:

$$
LMTD = \frac{(T_{h,in}-T_{c,out})-(T_{c,in}-T_{h,out})}{\ln(\frac{T_{h,in}-T_{c,out}}{T_{c,in}-T_{h,out}})}
$$

Knowing the heat exchanger area, the CAPEX can be computed as follow:

$$
CAPEX = F_{BM} \cdot C_p \cdot e \cdot a_n
$${#eq-CAPEX}

where:

- $F_{BM}$ is the bare module factor, which is assumed to be 4.74 since a fluid flows in the heat exchanger (Slide 10, T4.1)

- $C_p$ is the cost of the heat exchanger, which is computed as follow: $$C_p = \frac{I_t}{I_{t,ref}} \cdot 10^{k_1+k_2 \cdot \log(A_{ex})}$${#eq-Cp}
    - $I_t = 603.1$ is the investment cost index of the year of interest (2019) @noauthor_fluid_nodate
    - $I_{t,ref} = 389.5$ is the investment cost index of the reference year (1998) @noauthor_fluid_nodate
    - $k_1 = 3.6788$ and $k_2 = 0.4412$ are the constants of the equation (Slide 12, T4.1) for a spiral plate heat exchanger. This type of heat exchanger is assumed because of the area range.

- $e = 0.92 €/\$$ is the exchange rate between us dollar and euro.

- $a_n$ is the annualization factor, which is computed as follow: $$a_n = \frac{i(1+i)^n}{(1+i)^n-1} $${#eq-a_n}
    - $i = 0.05$ is the interest rate (Slide 8, T4.2)
    - $n = 20$ is the lifetime of the heat exchanger

#### Operating cost (OPEX)

Operating cost depends on three factors:

- Natural gas consumption for heating: $$c_{heating} = c_{gas} \cdot Q_{HEX} \cdot t_{op}$${#eq-heating}
    - $c_{gas} = 0.08 €/kWh$ is the price of natural gas in France and Germany
    - $Q_{HEX}$ is the heat exchanged between the two streams
    - $t_{op} = 24 \cdot 0.95 \cdot 365 h/year$ is the operating time of the heat exchanger
    - Assumption: $\eta_{boiler} = 1$

- Electricity consumption for cooling: $$c_{cooling} = c_{elec} \cdot \frac{Q_{HEX}}{COP} \cdot t_{op}$${#eq-cooling}
    - $c_{elec} = 0.12 €/kWh$ is the price of electricity in France, $0.21 €/kWh$ in Germany
    - $Q_{HEX}$ is the heat exchanged between the two streams
    - $COP = 3.5$ is the coefficient of performance of the heat pump

- Water consumption. However, water is considered as being used in a closed loop. Therefore, the cost in not considered in operation cost. It is neglected in CAPEX since the cost is small compared to the heat exchanger cost.

### Past 5 only

Here, Past 5 heat exchanger cost is optimized with respect to dTmin. In the following code, 1 stands for cold stream, and 2 for hot stream. When there is a T_#number, it is related to the entrance of the stream and _prime relate to the exiting. The _Number stands for the past number. Example: T2_prime_2 stands for the T_hout of the past2 HX, T1_5 stands for the T_cin of the past5 HX.

In this case, $T_{c,in} = 333K$ and $T_{h,in} = 348K$ are known. 


```{python Dtmin fct, echo = T, eval = T}

### Determine the area of the HX in term of the dTmin
import matplotlib
matplotlib.use('Agg')
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.graph_objects as go
from IPython.display import display, HTML
from codes_01_energy_bill.coolprop_functions import mixture

#####
def Dtmin(dT, T1, T1v, T2v, T2, m1, m2, cp1, cp2, position, pastnb):

    if position == 'right':
        T1_prime = T2 - dT
        T2_prime = T2v.min()
    elif position == 'left':
        T1_prime = T1v.max()
        T2_prime = T1 + dT #T1v.max()
    
    #Find the minimum Area of the HX
    Q = m2*cp2*(T2-T2_prime)
    #print('Q = ', round(Q, 3), 'W')
    alpha= 1000 #W/m^2°C, assumption based on alpha_H20
    U = alpha/2
    dtA = abs(T2-T1_prime)  # to be sure we have a positive value in the ln() of the LMTD
    dtB = abs(T1-T2_prime)
    LMTD = (dtA-dtB)/np.log(dtA/dtB)
    Area = Q/(U*LMTD)

    #Find the CAPEX

    CEPCI2019=603.1 
    CEPCI1998=389.5 #https://personalpages.manchester.ac.uk/staff/tom.rodgers/Interactive_graphs/CEPCI.html?reactors/CEPCI/index.html
    K1=3.6788 #sl 12 T4.1 assumption spiral plate HX
    K2=0.4412
    FBM=4.74 #assumption fluid sl 10 T4.1
    i=0.05 #sl 8 T4.2
    e=0.92 #€/$ exchange rate 2023 Nov 
    n=20

    Cp = CEPCI2019/CEPCI1998 * 10**(K1+K2*np.log(Area))

    CBM = Cp*FBM*e

    ANNUALIZATIONFACTOR = (i*(1+i)**n)/((1+i)**n-1)

    CAPEX = ANNUALIZATIONFACTOR*CBM

    #Find the OPEX
    top = 24*0.95*365 #h/year
    gas_fr = 0.08 # €/kWh
    gas_ger = 0.08 # €/kWh 
    elec_fr = 0.12 # €/kWh
    elec_ger = 0.21 # €/kWh
    COP = 3.5 #same assumption in Energy Bill

    if pastnb == 5:
        Qpast6 = m2*cp2*(T2-T1_prime)
        OP6_fr = gas_fr * Qpast6/1000 * top
        OP6_ger = gas_ger * Qpast6/1000 * top

        Qpast7 = m2*cp2*(T2_prime-277)  #T7 = 4°C = 277K
        Wpast7 = Qpast7/COP

        OP7_fr = elec_fr * Wpast7/1000 * top  
        OP7_ger = elec_ger * Wpast7/1000 * top 

        OPEX_fr = OP6_fr + OP7_fr
        OPEX_ger = OP6_ger + OP7_ger

    elif pastnb == 1:
        Qpast2 = m2*cp2*5 # dt = 5 in past 2
        Tpast2out = T1_prime + Qpast2/(m2*cp2)

        Qpast3 = m2*cp2*(Tpast2out-348)

        OP3_fr = gas_fr * Qpast3/1000 * top
        OP3_ger = gas_ger * Qpast3/1000 * top

        Qpast4 = m2*cp2*(T2_prime-277)  #T7 = 4°C = 277K
        Wpast4 = Qpast4/COP

        OP4_fr = elec_fr * Wpast4/1000 * top  
        OP4_ger = elec_ger * Wpast4/1000 * top 

        OPEX_fr = OP3_fr + OP4_fr
        OPEX_ger = OP3_ger + OP4_ger
    
    elif pastnb == 'cip':

        t_cip5 = 348
        t_cip2 = T1_prime
        t_cip1 = T1_prime
        m_cip2 = 4 
        m_cip1 = m1
        m_cip1 = m_cip2*(t_cip2-t_cip5)/(t_cip1-t_cip5) 
        m_cip5 = m_cip2-m_cip1

        Qsteam = m_cip2*cp1*(353-t_cip2)
        OP_steam_cip_fr = gas_fr * Qsteam/1000 * top
        OP_steam_cip_ger = gas_ger * Qsteam/1000 * top

        Qcool = m2*cp2*(T2_prime-303)
        Wcool = Qcool/COP
        OP_cool_cip_fr = elec_fr * Wcool/1000 * top
        OP_cool_cip_ger = elec_ger * Wcool/1000 * top

        OPEX_fr = OP_steam_cip_fr + OP_cool_cip_fr
        OPEX_ger = OP_steam_cip_ger + OP_cool_cip_ger

    elif pastnb == 'HX':

        tpasta = 273+65.9
        cppasta = 3400
        mpastx = 0.55
        mpasta = 0.48
        cppastx = 3498.64
        tpastx = (tpasta*mpasta*cppasta+T1_prime*m1*cp1)/(mpastx*cppastx)

        Qpast6 = mpastx*cppastx*(348-tpastx)

        OP6_fr = gas_fr * Qpast6/1000 * top
        OP6_ger = gas_ger * Qpast6/1000 * top

        Qpast4 = m2*cp2*(T2_prime-277)  #T7 = 4°C = 277K
        Wpast4 = Qpast4/COP

        OP4_fr = elec_fr * Wpast4/1000 * top  
        OP4_ger = elec_ger * Wpast4/1000 * top 

        OPEX_fr = OP6_fr + OP4_fr
        OPEX_ger = OP6_ger + OP4_ger


    #Find the TOTEX
    TOTEX_fr = CAPEX + OPEX_fr
    TOTEX_ger = CAPEX + OPEX_ger

    return CAPEX, OPEX_fr, OPEX_ger, TOTEX_fr, TOTEX_ger, Area, T1_prime, T2_prime
```

```{python past5only, echo = T, eval = T}
# Scenario 1: dTmin for the past5

T1_5 = 333
T2_5 = 348

p1_5 = 100000

m1_5 = 0.48
m2_5 = 0.55

State_Cold_1_5 = mixture(T=T1_5, P=p1_5, frac_water=0.65, frac_fat=0.35)
State_Cold_2_5 = mixture(T=T2_5, P=p1_5, frac_water=0.65, frac_fat=0.35)

h1_5 = State_Cold_1_5["enthalpy"] * m1_5  #from mixture with dry = 35% and wet = 65%
h2_5 = State_Cold_2_5["enthalpy"] * m2_5

cp1_5 = State_Cold_1_5["cpmass"]
cp2_5 = State_Cold_2_5["cpmass"]

slope1_5 = 1/(m1_5*cp1_5)
slope2_5 = 1/(m2_5*cp2_5)

#Plot the two lines with T on the y-axis and h on the x-axis
#h is the enthalpy of the stream between h1 and h2
N = 100
h_5 = np.linspace(h1_5, h2_5, N)

C1_5 = T1_5 - slope1_5*h1_5
T1v_5 = slope1_5*h_5 + C1_5

C2_5 = T2_5 - slope2_5*h2_5
T2v_5 = slope2_5*h_5 + C2_5


# Create trace for Cold Stream
trace_cold = go.Scatter(x=h_5, y=T1v_5, mode='lines', name='Cold Stream')
# Create trace for Hot Stream
trace_hot = go.Scatter(x=h_5, y=T2v_5, mode='lines', name='Hot Stream')
# Create layout
layout = go.Layout(
    title='Temperature vs Enthalpy',
    xaxis=dict(title='Enthalpy (J)'),
    yaxis=dict(title='Temperature (K)'),
    legend=dict(x=0, y=1, traceorder='normal'),
    showlegend=True
)
# Create figure
fig = go.Figure(data=[trace_cold, trace_hot], layout=layout)
# Plot the vertical line at dTmin
dt_5 = T2v_5 - T1v_5
dTmin_5 = dt_5.min()
min_index_5 = dt_5.argmin()
fig.add_shape(
    type='line',
    x0=h_5[min_index_5],
    x1=h_5[min_index_5],
    y0=min(T1v_5[min_index_5], T2v_5[min_index_5]),
    y1=max(T1v_5[min_index_5], T2v_5[min_index_5]),
    line=dict(color='red', dash='dash')
)

#print('dTmin =', round(dTmin_5, 3), 'K at h =', round(h_5[min_index_5], 3), 'kJ/kg')

#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results

CAPEXv_5 = []
OPEX_frv_5 = []
OPEX_gerv_5 = []
TOTEX_frv_5 = []
TOTEX_gerv_5 = []
Areav_5 = []

dt_5 = np.linspace(0.1, 30, 300)

for t in dt_5:
    CAPEX_5, OPEX_fr_5, OPEX_ger_5, TOTEX_fr_5, TOTEX_ger_5, Area_5 = Dtmin(t, T1_5, T1v_5, T2v_5, T2_5, m1_5, m2_5, cp1_5, cp2_5, 'right', 5)[0:6]
    CAPEXv_5.append(CAPEX_5)
    OPEX_frv_5.append(OPEX_fr_5)
    OPEX_gerv_5.append(OPEX_ger_5)
    TOTEX_frv_5.append(TOTEX_fr_5)
    TOTEX_gerv_5.append(TOTEX_ger_5)
    Areav_5.append(Area_5)

#plot the results with respect to the dt values

# Create traces for each cost component
trace_capex = go.Scatter(x=dt_5, y=CAPEXv_5, mode='lines', name='CAPEX', line=dict(color='black'))
trace_opex_france = go.Scatter(x=dt_5, y=OPEX_frv_5, mode='lines', name='OPEX (France)', line=dict(color='blue'))
trace_opex_germany = go.Scatter(x=dt_5, y=OPEX_gerv_5, mode='lines', name='OPEX (Germany)', line=dict(color='red'))
trace_totex_france = go.Scatter(x=dt_5, y=TOTEX_frv_5, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))
trace_totex_germany = go.Scatter(x=dt_5, y=TOTEX_gerv_5, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))

# Create layout
layout = go.Layout(
    title='Costs vs dTmin',
    xaxis=dict(title='dTmin (K)'),
    yaxis=dict(title='Costs (€)'),
    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),
    showlegend=True
)

# Create figure
fig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)

# Mark the minima points for both France and Germany
min_index_fr_5 = np.argmin(TOTEX_frv_5)
fig = fig.add_trace(go.Scatter(x=[dt_5[min_index_fr_5]], y=[TOTEX_frv_5[min_index_fr_5]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))

min_index_ger_5 = np.argmin(TOTEX_gerv_5)
fig = fig.add_trace(go.Scatter(x=[dt_5[min_index_ger_5]], y=[TOTEX_gerv_5[min_index_ger_5]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))

# Show the figure
fig.show()

#print the optimum values for dt, area, CAPEX, OPEX, TOTEX for both France and Germany (NB: even if we have the same CAPEX fct for both countries, the optimum CAPEX will be different in both countries because of the electricity/gas rate)

dtmin_fr_opt_5 = dt_5[min_index_fr_5]
dtmin_ger_opt_5 = dt_5[min_index_ger_5]
area_fr_opt_5 = Areav_5[min_index_fr_5]
area_ger_opt_5 = Areav_5[min_index_ger_5]
CAPEX_fr_opt_5 = CAPEXv_5[min_index_fr_5]
CAPEX_ger_opt_5 = CAPEXv_5[min_index_ger_5]
OPEX_fr_opt_5 = OPEX_frv_5[min_index_fr_5]
OPEX_ger_opt_5 = OPEX_gerv_5[min_index_ger_5]
TOTEX_fr_opt_5 = TOTEX_frv_5[min_index_fr_5]
TOTEX_ger_opt_5 = TOTEX_gerv_5[min_index_ger_5]

Past5_opt_fr_sc1 = pd.DataFrame({'dTmin_fr[K]': dtmin_fr_opt_5, 'Area_fr[m^2]': area_fr_opt_5, 'CAPEX_fr[€/yr]': CAPEX_fr_opt_5, 'OPEX_fr[€/yr]': OPEX_fr_opt_5, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_5}, index=[0])
Past5_opt_fr_sc1 = Past5_opt_fr_sc1.round(2)
HTML(Past5_opt_fr_sc1.to_html(index=False))

Past5_opt_ger_sc1 = pd.DataFrame({'dTmin_ger[K]': dtmin_ger_opt_5, 'Area_ger[m^2]': area_ger_opt_5, 'CAPEX_ger[€/yr]': CAPEX_ger_opt_5, 'OPEX_ger[€/yr]': OPEX_ger_opt_5, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_5}, index=[0])
Past5_opt_ger_sc1 = Past5_opt_ger_sc1.round(2)
HTML(Past5_opt_ger_sc1.to_html(index=False))
```

The T-h diagram shows that the dTmin is on the right of the curves. This determines the equations to use for the CAPEX.

The minimum value of TOTEX is graphically determined and is reported in the previous tables. The first table is for France and the second one for Germany.

### Past 1 + Past 5

This time we know only $T_{c,in}$ and $T_{c,out}$ but nothing about the hot streams.
We can't reuse the exact same method as for past5 where we knew $T_{h,in}$ and $T_{c,in}$
We will then first need to determine $T_{h,in}$ from the Past2 ∆T (assumed here at 5K for simplicity). We end up with a $T_{past,c} = 70°C$ which will be $T_{h,in}$ of past1.
Another important assumption in this scenario is to assume for past1 that $T_{c,out}=T_{past-cent,out} \ne 60°C$. Indeed, we will instead determine this temperature from the ∆Tmin optimization of past1.
From this new $T_{c,out}$, and because both past1 and past5 are linked by this flow we will recompute the ∆Tmin optimization of past5.

#### Past 1 optimization

```{python past1+5_past1, echo = T, eval = T}
from codes_01_energy_bill.coolprop_functions import mixture
# Scenario 2: dTmin for the past1+past5

####################################
############## PAST1 ##############
####################################

T1_1 = 277
T2_1 = 343

p1_1 = 100000

m1_1 = 8
m2_1 = 7.52

State_Cold_1_1 = mixture(T=T1_1, P=p1_1, frac_water=0.883, frac_fat=0.117)
State_Cold_2_1 = mixture(T=T2_1, P=p1_1, frac_water=0.883, frac_fat=0.117)

h1_1 = State_Cold_1_1["enthalpy"] * m1_1  #from mixture with dry = 11.7% and wet = 88.3%
h2_1 = State_Cold_2_1["enthalpy"] * m2_1

cp1_1 = State_Cold_1_1["cpmass"]
cp2_1 = State_Cold_2_1["cpmass"]

slope1_1 = 1/(m1_1*cp1_1)
slope2_1 = 1/(m2_1*cp2_1)

#Plot the two lines with T on the y-axis and h on the x-axis
#h is the enthalpy of the stream between h1 and h2
N = 100
h_1 = np.linspace(h1_1, h2_1, N)

C1_1 = T1_1 - slope1_1*h1_1
T1v_1 = slope1_1*h_1 + C1_1

C2_1 = T2_1 - slope2_1*h2_1
T2v_1 = slope2_1*h_1 + C2_1


# Create trace for Cold Stream
trace_cold = go.Scatter(x=h_1, y=T1v_1, mode='lines', name='Cold Stream')
# Create trace for Hot Stream
trace_hot = go.Scatter(x=h_1, y=T2v_1, mode='lines', name='Hot Stream')
# Create layout
layout = go.Layout(
    title='Temperature vs Enthalpy',
    xaxis=dict(title='Enthalpy (J)'),
    yaxis=dict(title='Temperature (K)'),
    legend=dict(x=0, y=1, traceorder='normal'),
    showlegend=True
)
# Create figure
fig = go.Figure(data=[trace_cold, trace_hot], layout=layout)
# Plot the vertical line at dTmin
dt_1 = abs(T2v_1 - T1v_1)
dTmin_1 = dt_1.min()
min_index_1 = dt_1.argmin()
fig = fig.add_shape(
    type='line',
    x0=h_1[min_index_1],
    x1=h_1[min_index_1],
    y0=min(T1v_1[min_index_1], T2v_1[min_index_1]),
    y1=max(T1v_1[min_index_1], T2v_1[min_index_1]),
    line=dict(color='red', dash='dash')
)
# Show the figure
fig.show()

#print('dTmin = ', round(dTmin_1,3), 'K at h = ', round(h_1[min_index_1],3), 'kJ/kg')

#This time the the dTmin is on the left of the curves and thus dTmin = T_hout-T_cin (instead of T_hin-Tcout as in past6)

#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results

CAPEXv_1 = []
OPEX_frv_1 = []
OPEX_gerv_1 = []
TOTEX_frv_1 = []
TOTEX_gerv_1 = []
Areav_1 = []

dt_1 = np.linspace(10, 65, 500)

for t in dt_1:
    CAPEX_1, OPEX_fr_1, OPEX_ger_1, TOTEX_fr_1, TOTEX_ger_1, Area_1 = Dtmin(t, T1_1, T1v_1, T2v_1, T2_1, m1_1, m2_1, cp1_1, cp2_1, 'left', 1)[0:6]
    CAPEXv_1.append(CAPEX_1)
    OPEX_frv_1.append(OPEX_fr_1)
    OPEX_gerv_1.append(OPEX_ger_1)
    TOTEX_frv_1.append(TOTEX_fr_1)
    TOTEX_gerv_1.append(TOTEX_ger_1)
    Areav_1.append(Area_1)

#plot the results with respect to the dt values

# Create traces for each cost component
trace_capex = go.Scatter(x=dt_1, y=CAPEXv_1, mode='lines', name='CAPEX', line=dict(color='black'))
trace_opex_france = go.Scatter(x=dt_1, y=OPEX_frv_1, mode='lines', name='OPEX (France)', line=dict(color='blue'))
trace_opex_germany = go.Scatter(x=dt_1, y=OPEX_gerv_1, mode='lines', name='OPEX (Germany)', line=dict(color='red'))
trace_totex_france = go.Scatter(x=dt_1, y=TOTEX_frv_1, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))
trace_totex_germany = go.Scatter(x=dt_1, y=TOTEX_gerv_1, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))

# Create layout
layout = go.Layout(
    title='Costs vs dTmin',
    xaxis=dict(title='dTmin (K)'),
    yaxis=dict(title='Costs (€)'),
    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),
    showlegend=True
)

# Create figure
fig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)

# Mark the minima points
min_index_fr_1 = np.argmin(TOTEX_frv_1)
fig = fig.add_trace(go.Scatter(x=[dt_1[min_index_fr_1]], y=[TOTEX_frv_1[min_index_fr_1]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))

min_index_ger_1 = np.argmin(TOTEX_gerv_1)
fig = fig.add_trace(go.Scatter(x=[dt_1[min_index_ger_1]], y=[TOTEX_gerv_1[min_index_ger_1]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))

# Show the figure
fig.show()

dtmin_fr_opt_1 = dt_1[min_index_fr_1]
dtmin_ger_opt_1 = dt_1[min_index_ger_1]
area_fr_opt_1 = Areav_1[min_index_fr_1]
area_ger_opt_1 = Areav_1[min_index_ger_1]
CAPEX_fr_opt_1 = CAPEXv_1[min_index_fr_1]
CAPEX_ger_opt_1 = CAPEXv_1[min_index_ger_1]
OPEX_fr_opt_1 = OPEX_frv_1[min_index_fr_1]
OPEX_ger_opt_1 = OPEX_gerv_1[min_index_ger_1]
TOTEX_fr_opt_1 = TOTEX_frv_1[min_index_fr_1]
TOTEX_ger_opt_1 = TOTEX_gerv_1[min_index_ger_1]

Past1_opt_fr_sc2 = pd.DataFrame({'dTmin_fr[K]': dtmin_fr_opt_1, 'Area_fr[m^2]': area_fr_opt_1, 'CAPEX_fr[€/yr]': CAPEX_fr_opt_1, 'OPEX_fr[€/yr]': OPEX_fr_opt_1, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_1}, index=[0])
Past1_opt_fr_sc2 = Past1_opt_fr_sc2.round(2)
HTML(Past1_opt_fr_sc2.to_html(index=False))

Past1_opt_ger_sc2 = pd.DataFrame({'dTmin_ger[K]': dtmin_ger_opt_1, 'Area_ger[m^2]': area_ger_opt_1, 'CAPEX_ger[€/yr]': CAPEX_ger_opt_1, 'OPEX_ger[€/yr]': OPEX_ger_opt_1, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_1}, index=[0])
Past1_opt_ger_sc2 = Past1_opt_ger_sc2.round(2)
HTML(Past1_opt_ger_sc2.to_html(index=False))
```

The first graph show dT is on the left and thus we will use the corresponding equation presented at the beginning of this section

The optimisation gives a dTmin which varies between Germany and France. This leads to different CAPEX and OPEX for both countries

For the OPEX we needed to inlude the costs of past3 (heating) and past 4 (cooling). 
Past 3 equation becomes the following: $Q_{past3} = m_{hot}*cp_{hot}*(T_{past2,out}-348)$ where $m_{hot}$ is the flow coming out of past2. Past 4 equation becomes the following: $m_{hot}*cp_{hot}*(T_{hot,out,past1}-277)$
Of course the heating OPEX (past 3) will use gas costs whereas the cooling OPEX (past 4) will use electricity costs and consider a COP of 3 as in energy bill. Both processes again assume the same operating time as for Energy Bill.

#### Past 5 optimization

Now we reperform the same as above but for past 5. This time because both past 1 and past 5 are connected we will assume $T_{cold,in,past5}=T_{hot,out,past1}$


```{python past1+5_past5, echo = T, eval = T}

####################################
############## PAST5 ##############
####################################

T1_prime_1_fr = Dtmin(dtmin_fr_opt_1, T1_1, T1v_1, T2v_1, T2_1, m1_1, m2_1, cp1_1, cp2_1, 'left', 1)[6]
T1_5 = T1_prime_1_fr #J'ai checké c'est 67°C donc bien inferieur au 70°C de T_hin=70° de past1 et bien inferieur au T_hint=75°C de past5
#Would be the same if we used dtmin_ger_opt_1 since T1_prime_1_ger = T1_prime_1_fr = T1v.max()


T2_5 = 348

p1_1 = 100000

m1_5 = 0.48
m2_5 = 0.55

State_Cold_1_5 = mixture(T=T1_5, P=p1_5, frac_water=0.65, frac_fat=0.35)
State_Cold_2_5 = mixture(T=T2_5, P=p1_5, frac_water=0.65, frac_fat=0.35)

h1_5 = State_Cold_1_5["enthalpy"] * m1_5  #from mixture with dry = 35% and wet = 65%
h2_5 = State_Cold_2_5["enthalpy"] * m2_5

cp1_5 = State_Cold_1_5["cpmass"]
cp2_5 = State_Cold_2_5["cpmass"]

slope1_5 = 1/(m1_5*cp1_5)
slope2_5 = 1/(m2_5*cp2_5)

#Plot the two lines with T on the y-axis and h on the x-axis
#h is the enthalpy of the stream between h1 and h2
N = 100
h_5 = np.linspace(h1_5, h2_5, N)

C1_5 = T1_5 - slope1_5*h1_5
T1v_5 = slope1_5*h_5 + C1_5

C2_5 = T2_5 - slope2_5*h2_5
T2v_5 = slope2_5*h_5 + C2_5


# Create trace for Cold Stream
trace_cold = go.Scatter(x=h_5, y=T1v_5, mode='lines', name='Cold Stream')
# Create trace for Hot Stream
trace_hot = go.Scatter(x=h_5, y=T2v_5, mode='lines', name='Hot Stream')
# Create layout
layout = go.Layout(
    title='Temperature vs Enthalpy',
    xaxis=dict(title='Enthalpy (J)'),
    yaxis=dict(title='Temperature (K)'),
    legend=dict(x=0, y=1, traceorder='normal'),
    showlegend=True
)
# Create figure
fig = go.Figure(data=[trace_cold, trace_hot], layout=layout)
# Plot the vertical line at dTmin
dt_5 = T2v_5 - T1v_5
dTmin_5 = dt_5.min()
min_index_5 = dt_5.argmin()
fig.add_shape(
    type='line',
    x0=h_5[min_index_5],
    x1=h_5[min_index_5],
    y0=min(T1v_5[min_index_5], T2v_5[min_index_5]),
    y1=max(T1v_5[min_index_5], T2v_5[min_index_5]),
    line=dict(color='red', dash='dash')
)

#print('dTmin =', round(dTmin_5, 3), 'K at h =', round(h_5[min_index_5], 3), 'kJ/kg')

#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results

CAPEXv_5 = []
OPEX_frv_5 = []
OPEX_gerv_5 = []
TOTEX_frv_5 = []
TOTEX_gerv_5 = []
Areav_5 = []

dt_5 = np.linspace(0.1, 30, 300)

for t in dt_5:
    CAPEX_5, OPEX_fr_5, OPEX_ger_5, TOTEX_fr_5, TOTEX_ger_5, Area_5 = Dtmin(t, T1_5, T1v_5, T2v_5, T2_5, m1_5, m2_5, cp1_5, cp2_5, 'right', 5)[0:6]
    CAPEXv_5.append(CAPEX_5)
    OPEX_frv_5.append(OPEX_fr_5)
    OPEX_gerv_5.append(OPEX_ger_5)
    TOTEX_frv_5.append(TOTEX_fr_5)
    TOTEX_gerv_5.append(TOTEX_ger_5)
    Areav_5.append(Area_5)

#plot the results with respect to the dt values

# Create traces for each cost component
trace_capex = go.Scatter(x=dt_5, y=CAPEXv_5, mode='lines', name='CAPEX', line=dict(color='black'))
trace_opex_france = go.Scatter(x=dt_5, y=OPEX_frv_5, mode='lines', name='OPEX (France)', line=dict(color='blue'))
trace_opex_germany = go.Scatter(x=dt_5, y=OPEX_gerv_5, mode='lines', name='OPEX (Germany)', line=dict(color='red'))
trace_totex_france = go.Scatter(x=dt_5, y=TOTEX_frv_5, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))
trace_totex_germany = go.Scatter(x=dt_5, y=TOTEX_gerv_5, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))

# Create layout
layout = go.Layout(
    title='Costs vs dTmin',
    xaxis=dict(title='dTmin (K)'),
    yaxis=dict(title='Costs (€)'),
    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),
    showlegend=True
)

# Create figure
fig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)

# Mark the minima points
min_index_fr_5 = np.argmin(TOTEX_frv_5)
fig = fig.add_trace(go.Scatter(x=[dt_5[min_index_fr_5]], y=[TOTEX_frv_5[min_index_fr_5]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))

min_index_ger_5 = np.argmin(TOTEX_gerv_5)
fig = fig.add_trace(go.Scatter(x=[dt_5[min_index_ger_5]], y=[TOTEX_gerv_5[min_index_ger_5]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))

# Show the figure
fig.show()

#print the area, dt, CAPEX, OPEX, TOTEX for the minimum TOTEX

dtmin_fr_opt_5 = dt_5[min_index_fr_5]
dtmin_ger_opt_5 = dt_5[min_index_ger_5]
area_fr_opt_5 = Areav_5[min_index_fr_5]
area_ger_opt_5 = Areav_5[min_index_ger_5]
CAPEX_fr_opt_5 = CAPEXv_5[min_index_fr_5]
CAPEX_ger_opt_5 = CAPEXv_5[min_index_ger_5]
OPEX_fr_opt_5 = OPEX_frv_5[min_index_fr_5]
OPEX_ger_opt_5 = OPEX_gerv_5[min_index_ger_5]
TOTEX_fr_opt_5 = TOTEX_frv_5[min_index_fr_5]
TOTEX_ger_opt_5 = TOTEX_gerv_5[min_index_ger_5]

Past5_opt_fr_sc2 = pd.DataFrame({'dTmin_fr[K]': dtmin_fr_opt_5, 'Area_fr[m^2]': area_fr_opt_5, 'CAPEX_fr[€/yr]': CAPEX_fr_opt_5, 'OPEX_fr[€/yr]': OPEX_fr_opt_5, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_5}, index=[0])
Past5_opt_fr_sc2 = Past5_opt_fr_sc2.round(2)
HTML(Past5_opt_fr_sc2.to_html(index=False))

Past5_opt_ger_sc2 = pd.DataFrame({'dTmin_ger[K]': dtmin_ger_opt_5, 'Area_ger[m^2]': area_ger_opt_5, 'CAPEX_ger[€/yr]': CAPEX_ger_opt_5, 'OPEX_ger[€/yr]': OPEX_ger_opt_5, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_5}, index=[0])
Past5_opt_ger_sc2 = Past5_opt_ger_sc2.round(2)
HTML(Past5_opt_ger_sc2.to_html(index=False))
```

The first graph show dT is on the right and thus we will use the corresponding equation presented at the beginning of this section

For the OPEX we needed to inlude the costs of past 6 (heating) and past 7 (cooling). 
Past 6 equation becomes the following: $Q_{past6} = m_{hot}*cp_{hot}*(T_{hot,in,past5}-T_{cold,out,past5})$ where $m_{hot}$ is the flow coming out of past5. Past 7 equation becomes the following: $m_{hot}*cp_{hot}*(T_{hot,out,past1}-277)$
Of course the heating OPEX (past 6) will use gas costs whereas the cooling OPEX (past 7) will use electricity costs and consider a COP of 3 as in energy bill. Both processes again assume the same operating time as for Energy Bill.

The optimisation gives a dTmin for past 5 of 6.3K leading to an area of 5.21$m^2$ and a larger TOTEX in Germany than France because of the higher price of electricity in Germany (both CAPEX are the same but OPEX vary). COmpared to case where only past5 were optimized we have a higher dTmin but a lower Area and thus lower costs. Considering only the costs of past5, it may seem more interesting to optimize past1 and past5 simultaneously. However we have to look at the whole picture and don't forget that past1 was also optimized (thus consider total costs of both past1 and past5).

#### Both costs combined 

Finaly, let's combine both costs from past 1 and past 5 to get the overall CAPEX, OPEX, and TOTEX for the two pasteurizers. This total costs will then be comapred to the energy bill without optimization over dTmin. 

```{python past1+5_overall, echo = T, eval = T}
####################################
############## PAST1 + PAST5 ##############
####################################

#Summarize the value for the overall optimum CAPEX, OPEX, and TOTEX of the two pasteurizers


CAPEX_fr_opt_15 = CAPEX_fr_opt_1 + CAPEX_fr_opt_5
CAPEX_ger_opt_15 = CAPEX_ger_opt_1 + CAPEX_ger_opt_5
OPEX_fr_opt_15 = OPEX_fr_opt_1 + OPEX_fr_opt_5
OPEX_ger_opt_15 = OPEX_ger_opt_1 + OPEX_ger_opt_5
TOTEX_fr_opt_15 = TOTEX_fr_opt_1 + TOTEX_fr_opt_5
TOTEX_ger_opt_15 = TOTEX_ger_opt_1 + TOTEX_ger_opt_5

Overall_opt_fr_sc2 = pd.DataFrame({'CAPEX_tot_fr[€/yr]': CAPEX_fr_opt_15, 'OPEX_tot_fr[€/yr]': OPEX_fr_opt_15, 'TOTEX_tot_fr[€/yr]': TOTEX_fr_opt_15}, index=[0])
Overall_opt_fr_sc2 = Overall_opt_fr_sc2.round(2)
HTML(Overall_opt_fr_sc2.to_html(index=False))

Overall_opt_ger_sc2 = pd.DataFrame({'CAPEX_tot_ger[€/yr]': CAPEX_ger_opt_15, 'OPEX_tot_ger[€/yr]': OPEX_ger_opt_15, 'TOTEX_tot_ger[€/yr]': TOTEX_ger_opt_15}, index=[0])
Overall_opt_ger_sc2 = Overall_opt_ger_sc2.round(2)
HTML(Overall_opt_ger_sc2.to_html(index=False))
```

### Past 5 + recovery HEX

The only possibility to recover heat in the pasteurisation section is by adding a new heat exchanger to preheat the thickener with the ouput milk flow. The following figure illustrate the location of this new heat exchanger.

![Pasteurisation](Figures/Recovery.jpg)

Assumption: crpast_b is fixed to 75°C. This assumption allows that past5 does not need to be reoptimized.

```{python past5 & HX recovery, echo = T, eval = T}
from pyxosmose.state import State

T1_hx = 277  #T_cip1 in CH2
T2_hx = 283.8  #T_cip6 in CH2

p1_hx = 100000

m1_hx = 0.07 #m_cip2 in CH2
m2_hx = 7.52 #m_cip6 in CH2

State_Cold_1_hx = mixture(T=T1_hx, P=p1_hx, frac_water=0.5, frac_fat=0.5)
State_Cold_2_hx = mixture(T=T2_hx, P=p1_hx, frac_water=0.883, frac_fat=0.117)

h1_hx = State_Cold_1_hx["enthalpy"] * m1_hx  
h2_hx = State_Cold_2_hx["enthalpy"] * m2_hx

print(' h1 =', round(h1_hx, 3), 'kJ/kg', '\n',
       'h2 =', round(h2_hx, 3), 'kJ/kg')
```

In this case, $h_1 > h_2$. The equation of T-h diagram is then:

$$
T_{cold}(h) = -\frac{h}{m_1 c_{p,1}} + T_{1} + \frac{h_1}{m_1 c_{p,1}}
$${#eq-slope_cold}

$$
T_{hot}(h) = -\frac{h}{m_2 c_{p,2}} + T_{2} + \frac{h_2}{m_2 c_{p,2}}
$${#eq-slope_hot}

```{python past5 & HX recovery 2, echo = T, eval = T}
cp1_hx = State_Cold_1_hx["cpmass"]
cp2_hx = State_Cold_2_hx["cpmass"]

slope1_hx = 1/(m1_hx*cp1_hx)
slope2_hx = 1/(m2_hx*cp2_hx)

#Plot the two lines with T on the y-axis and h on the x-axis
#h is the enthalpy of the stream between h1 and h2
N = 100

if h1_hx < h2_hx:
    h_hx = np.linspace(h1_hx, h2_hx, N)
    C1_hx = T1_hx - slope1_hx*h1_hx
    T1v_hx = slope1_hx*h_hx + C1_hx
    C2_hx = T2_hx - slope2_hx*h2_hx
    T2v_hx = slope2_hx*h_hx + C2_hx 
else:
    h_hx = np.linspace(h2_hx, h1_hx, N)
    C1_hx = T1_hx + slope1_hx*h1_hx
    T1v_hx = -slope1_hx*h_hx + C1_hx
    C2_hx = T2_hx + slope2_hx*h2_hx
    T2v_hx = -slope2_hx*h_hx + C2_hx


# Create trace for Cold Stream
trace_cold = go.Scatter(x=h_hx, y=T1v_hx, mode='lines', name='Cold Stream')
# Create trace for Hot Stream
trace_hot = go.Scatter(x=h_hx, y=T2v_hx, mode='lines', name='Hot Stream')
# Create layout
layout = go.Layout(
    title='Temperature vs Enthalpy',
    xaxis=dict(title='Enthalpy (J)'),
    yaxis=dict(title='Temperature (K)'),
    legend=dict(x=1, y=1, traceorder='normal'),
    showlegend=True
)
# Create figure
fig = go.Figure(data=[trace_cold, trace_hot], layout=layout)
# Plot the vertical line at dTmin
dt_hx = T2v_hx - T1v_hx
dTmin_hx = dt_hx.min()

min_index_hx = dt_hx.argmin()

fig.add_shape(
    type='line',
    x0=h_hx[min_index_hx],
    x1=h_hx[min_index_hx],
    y0=min(T1v_hx[min_index_hx], T2v_hx[min_index_hx]),
    y1=max(T1v_hx[min_index_hx], T2v_hx[min_index_hx]),
    line=dict(color='red', dash='dash')
)

print(' m_cold =', m1_hx, 'kg/s', '\n',
       'm_hot =', m2_hx, 'kg/s', '\n',
       'slope_cold =', slope1_hx, 'K/J', '\n',
       'slope_hot =', slope2_hx, 'K/J')
```

The cold line is over the hot line, which does not make sense in a thermodynamic point of view. This is due to the high difference between the two slopes. This is explained by the difference in mass flow. The thickener flow is about 100 times smaller than the output milk flow. It is not profitable to preheat the thickener with the output milk flow. There is no other place to use a recovery heat exchanger so no heat recovery is possible in the pasteurisation section.

### Cleaning in Place

Now let's only focus on another part of the process (the cleaning in place) and try to optimize the heat recovery. After looking for the heat exchanger in this process one can observe there is one used to heat thanks to use of steam between flows CIP2 and CIP3/10, and there is also one used to cool with glycolic water between flows CIP6 and CIP7.
We could try to use the second one (between CIP6 and CIP7) to preheat the flow cip1 with is currently at 25°C and which need to be heated to 60°C before entering the HX between CIP2 and CIP3/10.

NB: The same could have been done by preheating the CIP2 for it to be closer to CIP3 temperature of 80°C. However the gap would have been lowered (only 20°C difference compared to 35°C for the chosen solution) and thus the heat recovery would have been less efficient.
 
In chapter 2 when deermining heat and mass balances, the following relation had been determined between the flows temperatures:

- $T_cip6=75°C > T_{cip1}=25°C$

The new HX will placed such that CIP6 flow is first used to preheat CIP1 to CIP1' (with $T_{cip1'} > T_{cip1}$) and the exiting flows called CIP6' (such that $T_{cip6'}< T_{cip6}$) is then used to be cooled where CIP6 was previously. Hence, a system with less cooling is required since $T_{cip6'}< T_{cip6}$, as well as with also less heating required since $T_{cip1'} > T_{cip1}$.

![Optimized CIP](Figures/CIPoptimized.png)

Let's try to apply the method used for the pasterization:

```{python cip_heat_recovery, echo = T, eval = T}
from pyxosmose.state import State

T1_cip = 298  #T_cip1 in CH2
T2_cip = 348  #T_cip6 in CH2

p1_cip = 100000

m1_cip = 1.2 #m_cip2 in CH2
m2_cip = 1.2 #m_cip6 in CH2



State_Cold_1_cip = State(pair='TP', fluid='water', temperature=T1_cip, pressure=p1_cip)
State_Cold_1_cip.StateCalc()
State_Cold_1_cip = State_Cold_1_cip.__dict__ 

State_Cold_2_cip = State(pair='TP', fluid='water', temperature=T2_cip, pressure=p1_cip)
State_Cold_2_cip.StateCalc()
State_Cold_2_cip = State_Cold_2_cip.__dict__

h1_cip = State_Cold_1_cip["enthalpy"] * m1_cip  #from mixture with dry = 35% and wet = 65%
h2_cip = State_Cold_2_cip["enthalpy"] * m2_cip



cp1_cip = State_Cold_1_cip["cpmass"]
cp2_cip = State_Cold_2_cip["cpmass"]



slope1_cip = 1/(m1_cip*cp1_cip)
slope2_cip = 1/(m2_cip*cp2_cip)

#Plot the two lines with T on the y-axis and h on the x-axis
#h is the enthalpy of the stream between h1 and h2
N = 100
h_cip = np.linspace(h1_cip, h2_cip, N)

C1_cip = T1_cip - slope1_cip*h1_cip
T1v_cip = slope1_cip*h_cip + C1_cip

C2_cip = T2_cip - slope2_cip*h2_cip
T2v_cip = slope2_cip*h_cip + C2_cip


# Create trace for Cold Stream
trace_cold = go.Scatter(x=h_cip, y=T1v_cip, mode='lines', name='Cold Stream')
# Create trace for Hot Stream
trace_hot = go.Scatter(x=h_cip, y=T2v_cip, mode='lines', name='Hot Stream')
# Create layout
layout = go.Layout(
    title='Temperature vs Enthalpy',
    xaxis=dict(title='Enthalpy (J)'),
    yaxis=dict(title='Temperature (K)'),
    legend=dict(x=0, y=1, traceorder='normal'),
    showlegend=True
)
# Create figure
fig = go.Figure(data=[trace_cold, trace_hot], layout=layout)
# Plot the vertical line at dTmin
dt_cip = T2v_cip - T1v_cip
dTmin_cip = dt_cip.min()

min_index_cip = dt_cip.argmin()

fig.add_shape(
    type='line',
    x0=h_cip[min_index_cip],
    x1=h_cip[min_index_cip],
    y0=min(T1v_cip[min_index_cip], T2v_cip[min_index_cip]),
    y1=max(T1v_cip[min_index_cip], T2v_cip[min_index_cip]),
    line=dict(color='red', dash='dash')
)

#print('dTmin =', round(dTmin_cip, 3), 'K at h =', round(h_cip[min_index_cip], 3), 'kJ/kg')

#Redo the CAPEX/OPEX/TOTEX for different dT and plot the results

CAPEXv_cip = []
OPEX_frv_cip = []
OPEX_gerv_cip = []
TOTEX_frv_cip = []
TOTEX_gerv_cip = []
Areav_cip = []

dt_cip = np.linspace(5, 60)

for t in dt_cip:
    CAPEX_cip, OPEX_fr_cip, OPEX_ger_cip, TOTEX_fr_cip, TOTEX_ger_cip, Area_cip = Dtmin(t, T1_cip, T1v_cip, T2v_cip, T2_cip, m1_cip, m2_cip, cp1_cip, cp2_cip, 'right', 'cip')[0:6]
    CAPEXv_cip.append(CAPEX_cip)
    OPEX_frv_cip.append(OPEX_fr_cip)
    OPEX_gerv_cip.append(OPEX_ger_cip)
    TOTEX_frv_cip.append(TOTEX_fr_cip)
    TOTEX_gerv_cip.append(TOTEX_ger_cip)
    Areav_cip.append(Area_cip)

#plot the results with respect to the dt values

# Create traces for each cost component
trace_capex = go.Scatter(x=dt_cip, y=CAPEXv_cip, mode='lines', name='CAPEX', line=dict(color='black'))
trace_opex_france = go.Scatter(x=dt_cip, y=OPEX_frv_cip, mode='lines', name='OPEX (France)', line=dict(color='blue'))
trace_opex_germany = go.Scatter(x=dt_cip, y=OPEX_gerv_cip, mode='lines', name='OPEX (Germany)', line=dict(color='red'))
trace_totex_france = go.Scatter(x=dt_cip, y=TOTEX_frv_cip, mode='lines', name='TOTEX (France)', line=dict(color='blue', dash='dash'))
trace_totex_germany = go.Scatter(x=dt_cip, y=TOTEX_gerv_cip, mode='lines', name='TOTEX (Germany)', line=dict(color='red', dash='dash'))

# Create layout
layout = go.Layout(
    title='Costs vs dTmin',
    xaxis=dict(title='dTmin (K)'),
    yaxis=dict(title='Costs (€)'),
    legend=dict(x=0, y=-0.2, traceorder='normal', orientation='h'),
    showlegend=True
)

# Create figure
fig = go.Figure(data=[trace_capex, trace_opex_france, trace_opex_germany, trace_totex_france, trace_totex_germany], layout=layout)

# Mark the minima points for both France and Germany
min_index_fr_cip = np.argmin(TOTEX_frv_cip)
fig = fig.add_trace(go.Scatter(x=[dt_cip[min_index_fr_cip]], y=[TOTEX_frv_cip[min_index_fr_cip]], mode='markers', marker=dict(color='blue'), name='Min TOTEX (France)'))

min_index_ger_cip = np.argmin(TOTEX_gerv_cip)
fig = fig.add_trace(go.Scatter(x=[dt_cip[min_index_ger_cip]], y=[TOTEX_gerv_cip[min_index_ger_cip]], mode='markers', marker=dict(color='red'), name='Min TOTEX (Germany)'))

# Show the figure
fig.show()

#print the optimum values for dt, area, CAPEX, OPEX, TOTEX for both France and Germany (NB: even if we have the same CAPEX fct for both countries, the optimum CAPEX will be different in both countries because of the electricity/gas rate)

dtmin_fr_opt_cip = dt_cip[min_index_fr_cip]
dtmin_ger_opt_cip = dt_cip[min_index_ger_cip]
area_fr_opt_cip = Areav_cip[min_index_fr_cip]
area_ger_opt_cip = Areav_cip[min_index_ger_cip]
CAPEX_fr_opt_cip = CAPEXv_cip[min_index_fr_cip]
CAPEX_ger_opt_cip = CAPEXv_cip[min_index_ger_cip]
OPEX_fr_opt_cip = OPEX_frv_cip[min_index_fr_cip]
OPEX_ger_opt_cip = OPEX_gerv_cip[min_index_ger_cip]
TOTEX_fr_opt_cip = TOTEX_frv_cip[min_index_fr_cip]
TOTEX_ger_opt_cip = TOTEX_gerv_cip[min_index_ger_cip]

CIP_opt_fr = pd.DataFrame({'dTmin_fr[K]': dtmin_fr_opt_cip, 'Area_fr[m^2]': area_fr_opt_cip, 'CAPEX_fr[€/yr]': CAPEX_fr_opt_cip, 'OPEX_fr[€/yr]': OPEX_fr_opt_cip, 'TOTEX_fr[€/yr]': TOTEX_fr_opt_cip}, index=[0])
CIP_opt_fr = CIP_opt_fr.round(2)
HTML(CIP_opt_fr.to_html(index=False))

CIP_opt_ger = pd.DataFrame({'dTmin_ger[K]': dtmin_ger_opt_cip, 'Area_ger[m^2]': area_ger_opt_cip, 'CAPEX_ger[€/yr]': CAPEX_ger_opt_cip, 'OPEX_ger[€/yr]': OPEX_ger_opt_cip, 'TOTEX_ger[€/yr]': TOTEX_ger_opt_cip}, index=[0])
CIP_opt_ger = CIP_opt_ger.round(2)
HTML(CIP_opt_ger.to_html(index=False))

```

In this scenario the OPEX is dependent on the the cooling and heating HX of the CIP process. First  new flows are redetermined for m_cip1 and m_cip5 such that $m_{cip1} = m_{cip2}*\frac{T_{cip2}-T_{cip5}}{T_{cip1}-T_{cip5}}$ and $m_{cip5}=m_{cip2}-m_{cip1}$ where $T_{cip1}$=$T_{cip2}$=$T_{cold,out,newHX}$ the new exiting temperature cip1' hotter than cip1 from the task2.
From this, $Q_{steam} = m_{cip2}*cp1*(353-T_{cip2})$ and $Q_{cooling} = m_{hot,newHX}*cp_{hot,newHX}*(T_{hot,out,newHX}-303)$ 


It can be observed that the optimum dT is 24°C which brings CIP1' to ($75-24=51°C$) instead of 25°C. Thus compared to the case without optimization CIP2 will be cooler than 60°C and thus the heat exchanger between CIP2 and CIP3/10 will require more steam to heat up until 80°C. This doesn't seem to be efficient. This will check by comparing the costs with the Energy Bill.

### Comparison with non-optimalized case:

In each case presented above, optimized dTmin have been selected to reduce cost of the considered system. But then even by selecting this minimum cost, is this heat recovery optimization really worth it? To check this, comparison will now be made with the non-optimized cases from the Energy Bill.

The following table sumarize the cost for the optimized (with heat recovery) and non-optimized (without heat recovery) OPEX for each process. The costs are given for both France and Germany. Only OPEX are considered since in the Energy Bill only OPEX were computed so it is not possible to compare CAPEX and TOTEX.



<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-fpwh{background-color:#32cb00;border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}
.tg .tg-rh1i{background-color:#cb0000;border-color:inherit;color:#333333;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-1jni{background-color:#cb0000;border-color:inherit;text-align:center;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0pky"></th>
    <th class="tg-0pky">Non optimized OPEX <span style="font-weight:400;font-style:normal;text-decoration:none">[€/yr]</span> (Task3)</th>
    <th class="tg-0pky">Optimized OPEX [€/yr] (w/ heat recovery)</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-c3ow" colspan="3">Scenario 1: Past5 only</td>
  </tr>
  <tr>
    <td class="tg-0pky">France</td>
    <td class="tg-c3ow">59944.08</td>
    <td class="tg-fpwh">44419.74</td>
  </tr>
  <tr>
    <td class="tg-0pky">Germany</td>
    <td class="tg-c3ow">87121.35</td>
    <td class="tg-fpwh">68745.31</td>
  </tr>
  <tr>
    <td class="tg-c3ow" colspan="3">Scenario 2: Past1+Past5</td>
  </tr>
  <tr>
    <td class="tg-0pky">France</td>
    <td class="tg-c3ow">305650.42</td>
    <td class="tg-1jni">520170.36</td>
  </tr>
  <tr>
    <td class="tg-0pky">Germany</td>
    <td class="tg-c3ow">374421.76</td>
    <td class="tg-rh1i">665505.52</td>
  </tr>
  <tr>
    <td class="tg-c3ow" colspan="3">Scenario 3: Past5+ new HX</td>
  </tr>
  <tr>
    <td class="tg-0pky">France</td>
    <td class="tg-c3ow">-</td>
    <td class="tg-c3ow">Not possible</td>
  </tr>
  <tr>
    <td class="tg-0pky">Germany</td>
    <td class="tg-c3ow">-</td>
    <td class="tg-c3ow">Not possible </td>
  </tr>
  <tr>
    <td class="tg-c3ow" colspan="3">Scenario 4: CIP</td>
  </tr>
  <tr>
    <td class="tg-0pky">France</td>
    <td class="tg-c3ow">287303.02</td>
    <td class="tg-1jni">316820.95</td>
  </tr>
  <tr>
    <td class="tg-0pky">Germany</td>
    <td class="tg-c3ow">335652.89</td>
    <td class="tg-fpwh">311564.64</td>
  </tr>
</tbody>
</table>


## Minimum energy requirement

The minimum energy requirement, including both heat and cooling demand, can be determined through the application of pinch analysis. <!--In the Survival Guide, you can find an example of using QRosmose to conduct pinch analysis for a brewery plant. For your project, you are expected to employ the same methodology to analyze the dairy factory. While more detailed tutorials will be provided during the semester, the TA team will also be available to assist you as needed.-->

<!--In your report, we would like to see the following:-->

<!-- - Brief Introduction to Pinch Analysis: Provide a **short** introduction to pinch analysis and explain how it is used to calculate the minimum energy requirement.-->
<!-- - Analysis Results: Present the outcomes of your analysis, including any assumptions you have made. An essential question to address is: How do you determine the minimum temperature difference for the entire system? This question has not been adequately answered by previous students in this course.

Furthermore, feel free to utilize R and Python code chunks to generate visually appealing graphs and tables. You can refer to the examples provided below or in the Survival Guide.-->

### Introduction to Pinch Analysis

When designing a process, engineers primarily address three concerns: they aim to recover process heat wherever possible, maximize process-to-process exchanges, and minimize the Heat Exchanger Network (HEN). 

To achieve this, H-T diagrams are employed to determine the minimal temperature difference between hot and cold exchanges, defining it as the pinch point. Subsequently, the process is partitioned into cold and hot areas, both in relation to the pinch point. 

The fundamental concept of pinch analysis is to optimize heat exchanges between these two areas. 

This analysis unfolds in three steps: first, hot and cold streams are defined; second, the minimum energy requirement is computed (the target step); and finally, the synthesis step is executed by enhancing the HEN.

This methodology is thus known as the pinch point analysis, and we will show the results of this analysis in the next part of this report.

### Analysis Results

In this section we will show the results of our pinch analysis. First we will show the composite curves (Fig. 1) and the grand composite curve (Fig. 2). 

From the composite curves we are then able to extrapolate the energy requirements, the heat recovery and the utilities, by separating the graph in three portions with two green dotted lines, showing the boundaries of the utilities and the heat recovery.

We can also use the graph of the grand composite curve to determine the temperature of the pinch points. These are the points where the heat load is equal to 0, meaning that the heats of the corrected cold and hot streams are the same in these points. We do not consider the two points at the edges of the temperature values since they're not pinch points.

We will start by showing the composite curves first:

```{r}
library(jsonlite)
pfilename<-"codes_02_heat_recovery/result/brewery-1.json"
data <- fromJSON(pfilename, flatten=FALSE)
totex<-data$results$KPIs$totalcost
capex<-data$results$KPIs$capex
opex<-data$results$KPIs$opex

costs<-data.frame(totex, opex, capex)
```


<!--

```{r costs-tab, tidy=T}
knitr::kable(
  costs, caption = 'Here is a nice table',
  booktabs = TRUE
)
```

-->




```{python, echo = T, eval = T, fig.cap='Fig. 1: Composite Curves'}
import matplotlib.pyplot as plt
import json
import numpy as np

plt.switch_backend('agg')

# read json for heat integration data
file_name = open('codes_02_heat_recovery/result/brewery-1.json')
integ = json.loads(file_name.read())

# we used .keys() and json-reader to locate the data of interest (hot and cold composite curves)
hotcc = integ["results"]["graph"][0][0][1]["data"][0]["curve"]
coldcc = integ["results"]["graph"][0][0][1]["data"][1]["curve"]

# extract the temperature (T in Kelvin) and heat (Q in kW)
T_hc = [i["T"] for i in hotcc]
Q_hc = [i["Q"] for i in hotcc]
T_cc = [i["T"] for i in coldcc]
Q_cc = [i["Q"] for i in coldcc]

# compute the shifted carnot factor (1 - T0/T) and Treference = 298.15K
Tref = 298.15 
ca_hc = [(1-Tref/i) for i in T_hc]
ca_cc = [(1-Tref/i) for i in T_cc]

# compute back the original carnot factors given a deltaT_min
deltaT_min = 40
T_hc_ori = [(i+deltaT_min/2) for i in T_hc]
T_cc_ori = [(i-deltaT_min/2) for i in T_cc]
ca_hc_ori = [(1-298.15/i) for i in T_hc_ori]
ca_cc_ori = [(1-298.15/i) for i in T_cc_ori]

# prepare the second y-axis for plotting
# the minim carnot value is extracted from the original cooling. Round it to the lowest .0
# the maximum carnot carnot value is extracted from the original heating. Round it to the highest .0
ca_min = round(min(ca_cc_ori) - 0.05, 1)
ca_max = round(max(ca_hc_ori) + 0.05, 1)
# generate an array with the carnot list from min to max
ca_values = np.arange(ca_min, ca_max, 0.2)
# compute the corresponding temperature values in celcius
Tref_ce = 298.15
T_ce = [int(Tref_ce/(1-i) - 273.15) for i in ca_values]

# plot the composite curves
figure, ax = plt.subplots(figsize = (8,6))

# both cold curves (blue): dashed --> shifted, solid --> original
ax.plot(Q_cc, ca_cc, "--b")
ax.plot(Q_cc, ca_cc_ori, "-b")
# both hot curves (red): dashed --> shifted, solid --> original
ax.plot(Q_hc, ca_hc, "--r")
ax.plot(Q_hc, ca_hc_ori, "-r")
# fill the area between the original and shifted curves
ax.fill_between(Q_cc, ca_cc_ori, ca_cc, color="blue", alpha=0.25)
ax.fill_between(Q_hc, ca_hc, ca_hc_ori, color="red", alpha=0.25)

# add the lables and title
ax.set_xlabel('$Heat \ Load \ (kW)$', labelpad=12)
ax.set_ylabel('$Carnot \ Factor \ (1 - T_{0}/T)$')
ax.set_title('$Composite \ Curves$')
ax.legend(["Corrected Cold Composite Curve", "Cold Composite Curve", "Corrected Hot Composite Curve", "Hot Composite Curve"])
ax.set_ybound(ca_min, ca_max)

# secondary axis. In this case we don't plot anything, we simply set the secondary axis ticks
ax2 =ax.twinx()
ax2.set_yticks(np.arange(0, len(T_ce), 1), T_ce)
ax2.set_ylabel('$Temperature \ (\u00b0C)$', labelpad=10)

plt.axvline(x=24946.177132, color="green", linestyle="--")
plt.axvline(x=2975.059841, color="green", linestyle="--")

plt.show()

# save the plot as a png
figure.savefig("composite_curves.png", format="png", dpi=600)
```

Here is the grand composite curve:
```{python, echo = T, eval = T, fig.cap='Fig. 2: Grand Composite Curve'}

Q_gcc = np.zeros(len(Q_cc))

for i in range(len(Q_cc)):
  Q_gcc[i] = Q_cc[i] - Q_hc[i]  

for i in range(len(T_hc)):
  T_hc[i] = T_hc[i] - 273.15

figure, ax = plt.subplots(figsize = (8,6))

ax.plot(Q_gcc, T_hc, "-g")
plt.axhline(y=0, color='black', linestyle='--')


ax.set_xlabel('$Heat \ Load \ (kW)$', labelpad=12)
ax.set_ylabel('$Temperature \ (°C)$')
ax.set_title('$Grand \ Composite \ Curve$')
ax.legend(["Grand Composite Curve"])
ax.set_ybound(-100, 1200)

plt.show()

Heat_inter = []
intersections = []
for i in range(len(Q_gcc)):
  if (Q_gcc[i]<=10):
    if (T_hc[i]>=0 and T_hc[i]<=1000):
      intersections.append(T_hc[i])
      Heat_inter.append(Q_gcc[i])
#print("We can observe two pinch points at the temperatures:", intersections, " (°C)")
#print(np.max(ca_hc_ori))
#print(np.min(ca_cc_ori))

upper_bound = 0
lower_bound = 5000
for i in range(len(Q_hc)):
  if (ca_hc_ori[i] < (np.max(ca_hc_ori)) and Q_hc[i] > upper_bound):
    upper_bound = Q_hc[i]
  if (ca_cc_ori[i] > np.min(ca_cc_ori) and Q_cc[i] < lower_bound):
    lower_bound = Q_cc[i]
#print(lower_bound, upper_bound)
#print("We find that the maximum heat recovery potential is equal to", np.round(upper_bound - lower_bound, 2), " W.")
```

In the next tables we will show the temperatures of the pinch points and the energy requirements and heat recovery:

```{python, echo = T, eval = T}
import pandas as pd
import numpy as np
from IPython.display import display, HTML


cold_utilities = lower_bound
total_w = 0

for i in range(len(Q_cc)):
  if ((ca_cc_ori[i] > 0.4) and (Q_cc[i] > total_w)):
    total_w = Q_cc[i]


hot_utilities = total_w - upper_bound

#print("The cold utilities require", cold_utilities, "W and the hot utilities need", hot_utilities, "W of energy. In total, the minimum energy requirements are of", (cold_utilities+hot_utilities),"W.")




data_pinch_points = {'Pinch Points': ['Pinch Point 1', 'Pinch Point 2'],
        'Temperature (°C)': [ intersections[0], intersections[1]]}

dfs = pd.DataFrame(data_pinch_points)
dfs = dfs.set_index('Pinch Points')
dfs = dfs.round(2)
HTML(dfs.to_html())
```

We can check that the heat load at these points is indeed 0 W by extracting its value at these points:

```{python, echo = T, eval = T}
data_pinch_points = {'Pinch Points': ['Pinch Point 1', 'Pinch Point 2'],
        'Heat (W)': [ Heat_inter[0], Heat_inter[1]]}

dfs = pd.DataFrame(data_pinch_points)
dfs = dfs.set_index('Pinch Points')
HTML(dfs.to_html())
```

These values can indeed be approximated to 0 W.

We are also able to compute the energy requirements and maximum heat recovery:
```{python, echo = T, eval = T}
data_heat_recovery = {'Information': ['Cold Utilities', 'Hot Utilities', 'Minimum Energy Requirements', 'Maximum Heat Recovery Potential'],
        'Heat (W)': [cold_utilities, hot_utilities, cold_utilities+hot_utilities, np.round(upper_bound - lower_bound, 2)]}

dfs = pd.DataFrame(data_heat_recovery)
dfs = dfs.set_index('Information')
dfs = dfs.round(2)
HTML(dfs.to_html())

```